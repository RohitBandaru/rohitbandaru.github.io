<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="4zEwdc_gZtK7GAY69eUGNqwH6-hIgaXtASEwUuEDEho"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Transformer Design Guide (Part 1: Vanilla) | Rohit Bandaru </title> <meta name="author" content="Rohit Bandaru"> <meta name="description" content="ML blog."> <meta name="keywords" content="machine-learning, ai, artificial-intelligence, research"> <meta property="og:site_name" content="Rohit Bandaru"> <meta property="og:type" content="article"> <meta property="og:title" content="Rohit Bandaru | Transformer Design Guide (Part 1: Vanilla)"> <meta property="og:url" content="https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt1/"> <meta property="og:description" content="ML blog."> <meta property="og:image" content="https://rohitbandaru.github.io/assets/img/blog/transformer_pt1/transformer.png"> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Transformer Design Guide (Part 1: Vanilla)"> <meta name="twitter:description" content="ML blog."> <meta name="twitter:image" content="https://rohitbandaru.github.io/assets/img/blog/transformer_pt1/transformer.png"> <meta name="twitter:site" content="@rohit_bandaru"> <meta name="twitter:creator" content="@rohit_bandaru"> <script type="application/ld+json">
    {
        "author":
        {
            "@type": "Person",
            "name": "Rohit Bandaru"
        },
        "url": "https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt1/",
        "@type": "BlogPosting",
        "description": "ML blog.",
        "headline": "Transformer Design Guide (Part 1: Vanilla)",
        
        "sameAs": ["https://www.linkedin.com/in/rohit-bandaru", "https://twitter.com/rohit_bandaru"],
        
        "name": "Rohit Bandaru",
        "@context": "https://schema.org"
    }
  </script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%A4%96&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt1/"> <script src="/assets/js/theme.js?bd888c560287cd675855c7662a167c4a"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Rohit</span> Bandaru </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/notes/">notes </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Transformer Design Guide (Part 1: Vanilla)</h1> <p class="post-meta"> Created in November 03, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/transformer"> <i class="fa-solid fa-hashtag fa-sm"></i> transformer</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>The Transformer architecture has emerged as the cornerstone of deep learning and artificial intelligence. Despite its conceptual simplicity, the specific details of the architecture can be difficult to understand and reason about. This two-part blog series aims to provide a thorough examination of the Transformer, demystifying its core components and recent advancements. The goal is to cover the fundamental and cutting-edge concepts needed to design transformer-based models for any application in any modality.</p> <p>This blog post will be in two parts:</p> <p><strong>Part 1 will be a deep dive of the standard Transformer architecture.</strong> It is a highly modular architecture, so we will explain each component in detail and how they integrate. This will also cover how to design the components for different use cases. It was introduced by the famous paper <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank">Attention Is All You Need</a>. There is no shortage of resources to learn about transformers, but I hope to offer some new perspectives.</p> <p><strong>Part 2 will cover recent advancements that have further advanced the capabilities of transformers.</strong> The original transformer architecture is robust and versatile and has led to many successful applications. However, in recent years with the surge in investment into transformers / LLMs, we have seen many useful advances. These impart new capabilities such as longer context length, faster training, and more efficient inference. This is a guide to designing modern transformer architectures for any use case.</p> <h1 id="transformer-architecture">Transformer Architecture</h1> <p><a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank">Attention Is All You Need</a> introduced the transformer architecture in 2017 specifically for machine translation. Since then, architectures derived from this have been used not only for various NLP tasks but also for other modalities such as vision, audio, and time series. We’ll take a modality-agnostic approach. As we explore each component, we’ll focus on how to design it for different modalities and use cases. For instance, position embeddings might be designed differently for text than for images.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/transformer-480.webp 480w,/assets/img/blog/transformer_pt1/transformer-800.webp 800w,/assets/img/blog/transformer_pt1/transformer-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/transformer.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="Transformer diagram" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Annotated from source: <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>Transformers are so generalizable because they have relatively few inductive biases. Unlike CNNs, which require Euclidean input, Transformers do not enforce a data structure. It is up to the designer to incorporate domain-specific inductive biases into the model. These design decisions are important for the model to be effective at a given task.</p> <hr> <p>The transformer architecture can be understood as 3 steps.</p> <ol> <li>Input processing (Generation of a set of embeddings to input into the transformer)</li> <li>Transformer blocks (Bulk of the computation)</li> <li>Output processing (Using the output embeddings of the transformer to perform a task and train the model)</li> </ol> <h1 id="input-processing">Input Processing</h1> <p>The input to the transformer is an unordered set of embeddings. These embeddings are high dimension vectors of floating point values that represent a part of the input. We refer to input processing as the steps taken to compute these embeddings. Input processing changes the most between modalities.</p> <p>The general pattern for input processing is as follows</p> <ol> <li>Split up the input into pieces</li> <li>Map each piece to an embedding</li> </ol> <p>The output of these two steps is a set of embeddings that represent the raw input in a way the transformer architecture can process.</p> <h2 id="image-processing">Image Processing</h2> <p>Transformers for images were introduced in the <a href="https://arxiv.org/abs/2010.11929" rel="external nofollow noopener" target="_blank">ViT</a> paper. The input image is processed in two steps:</p> <ol> <li>The image is split into patches of 16x16.</li> <li>The pixel values of each patch are flattened to vector and fed through a learned linear projection, resulting in patch embeddings.</li> </ol> <p>The result is a set of embeddings that can be processed by the transformer.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/vit_input-480.webp 480w,/assets/img/blog/transformer_pt1/vit_input-800.webp 800w,/assets/img/blog/transformer_pt1/vit_input-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/vit_input.png" width="100%" height="auto" alt="Image Tokenization" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> </figcaption> </figure> <h2 id="text-tokenizer">Text Tokenizer</h2> <p>Text is represented as a sequence of characters or bytes. Unlike images, text isn’t inherently numerical data that can be directly transformed into embeddings. Text is processed by tokenization, which is mapping it to a sequence of discrete tokens. Tokenizers create a vocabulary, which is mapping of all possible tokens to vocab indices. These indices are used to retrieve a learned embedding from a table. Text input processing involves two steps: tokenization and embedding lookup.</p> <p>Let’s consider two basic options for tokenization:</p> <ul> <li> <strong>Character-Level Tokenization:</strong> Every character in the text becomes a separate token. This creates a very long sequence but has a very small vocabulary.</li> <li> <strong>Word-Level Tokenization:</strong> Each word is a distinct token. This results in a more manageable sequence length but results in a huge vocabulary.</li> </ul> <p>There is an obvious tradeoff between vocabulary size and input size. Character-level tokenization creates very long sequences, which can be inefficient for transformers. On the other hand, word-level tokenization can lead to a massive vocabulary size, requiring a large embedding table. This can be computationally expensive and struggle with unseen words or typos.</p> <p>The ideal approach considers several factors:</p> <ul> <li> <strong>Sequence Length:</strong> Shorter sequences are generally more efficient for processing, but extremely short sequences may not capture enough context.</li> <li> <strong>Embedding Table Size:</strong> A larger vocabulary requires a bigger embedding table, increasing memory usage and training time.</li> <li> <strong>Rare Words:</strong> Very infrequent tokens may not be adequately learned during training, impacting model performance.</li> <li> <strong>Token Complexity:</strong> A single token shouldn’t represent too much information. Complex concepts might benefit from being broken down into smaller tokens for better processing by the model.</li> </ul> <p>In practice, finding the right balance often involves a compromise between character-level and word-level tokenization. Techniques like subword tokenization (splitting words into smaller meaningful units) can offer a middle ground, achieving a balance between sequence length, vocabulary size, and capturing text information effectively.</p> <h3 id="byte-pair-encoding-bpe">Byte Pair Encoding (BPE)</h3> <p>The most common approach to implementing sub-word tokenization is Byte Pair Encoding (BPE).</p> <p>It works by first starting with the individual characters (bytes) in the text as its initial vocabulary. This ensures that all text can be encoded, though not efficiently. BPE then iteratively identifies the most frequently occurring pair of characters and merges them into a single new token. This process continues until a predefined maximum number of tokens is reached, preventing the vocabulary from becoming too large.</p> <p>One interesting feature of this approach is that the tokenizer uses a small and separate dataset for BPE. This dataset can be engineered to achieve certain properties in the tokenizer. For example, it is beneficial for this data to be balanced between different languages. For example, if the amount of data for Japanese is significantly lower than that for English. Rare pairs in English would be prioritized over common pairs in Japanese. This would be unfair to Japanese, and Japanese text would require far more tokens. To address this, the tokenizer dataset can be balanced between different languages.</p> <p>See <a href="https://platform.openai.com/tokenizer" rel="external nofollow noopener" target="_blank">platform.openai.com/tokenizer</a> for an interactive demo on how text is tokenized and mapped in token indices.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/text_tokenization-480.webp 480w,/assets/img/blog/transformer_pt1/text_tokenization-800.webp 800w,/assets/img/blog/transformer_pt1/text_tokenization-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/text_tokenization.png" width="100%" height="auto" alt="Example of tokenized text." loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Example of tokenized text <a href="https://platform.openai.com/tokenizer" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/token_indices-480.webp 480w,/assets/img/blog/transformer_pt1/token_indices-800.webp 800w,/assets/img/blog/transformer_pt1/token_indices-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/token_indices.png" width="100%" height="auto" alt="Generated token indices" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Generated token indices <a href="https://platform.openai.com/tokenizer" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>BPE also involves some hardcoded rules. Some bytes, such as punctuation can be ignored in the tokenizer merging. GPT tokenizers use different regex patterns to split the string prior to tokenization to prevent certain bytes from merging.</p> <p>BPE is expensive to run and to encode/decode text since it is an iterative process. This is optimized by OpenAI (<a href="https://github.com/openai/tiktoken" rel="external nofollow noopener" target="_blank">tiktoken</a>) by implementing it in Rust. <a href="https://github.com/google/sentencepiece" rel="external nofollow noopener" target="_blank">SentencePiece</a> by Google is another popular tokenizer. SentencePiece runs BPE on Unicode code points (Unicode characters). It falls back to bytes for rare code points. Unicode has nearly 150k code points, a large number of which are very rare. Most tokenizers use less than 100k tokens. Having 150k tokens before adding more through BPE is not practical.</p> <p>Once we have a trained tokenizer, we use it to map input text to token indices. These token indices are mapped to learned embeddings. Transformer models often include embedding tables, which store learned embeddings for each item in the model’s vocabulary.</p> <p>See this <a href="https://www.youtube.com/watch?v=zduSFxRajkE&amp;t=24s&amp;ab_channel=AndrejKarpathy" rel="external nofollow noopener" target="_blank">video</a> by Andrej Karpathy for a deep dive into text tokenizers.</p> <h2 id="audio-and-other-modalities">Audio and Other Modalities</h2> <p>Like images, audio is a continuous data modality. A popular method of tokenizing audio is to generate a spectrogram using a Fourier Transform. This creates an image that can be tokenized in the same way as images in ViT. The <a href="https://arxiv.org/abs/2104.01778" rel="external nofollow noopener" target="_blank">AST: Audio Spectrogram Transformer</a> paper does exactly this.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/audio_input-480.webp 480w,/assets/img/blog/transformer_pt1/audio_input-800.webp 800w,/assets/img/blog/transformer_pt1/audio_input-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/audio_input.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="Audio tokenization from AST" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Audio tokenization from AST <a href="https://arxiv.org/abs/2104.01778" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>This paper uses a 2D position embedding so they can warmstart from a ViT model. If it were to train from audio only, a 1D position embedding could be used, as in OpenAI’s <a href="https://arxiv.org/abs/2212.04356" rel="external nofollow noopener" target="_blank">Whisper</a>.</p> <p>We have covered the basic methods for tokenizing text and continuous data domains, however, there is a lot of research covering alternative methods. This includes vector quantization which generates discrete tokens from continuous data modalities.</p> <h1 id="position-embedding">Position Embedding</h1> <p>The transformer takes a set of tokens as input. However, many inputs are better represented as sequences, such as text and audio Where a token occurs in the sequence is a crucial piece of information. Position embeddings can be added to the token embeddings to encode the position of the token in the sequence. Although the input is still a set, we are not losing the information of the order of the tokens within the input sequence. Position embeddings implicitly turn the transformer from a set processing architecture to a sequence processing one.</p> <p>The original transformer paper evaluates two methods of configuring the position embedding. These have equivalent results.</p> <ul> <li>Learned: A separate learned embedding is used for every position in the sequence up to the maximum sequence length.</li> <li>Fixed: The embedding values aren’t learned but are configured as a function of the position. \(i\) is the index in the embedding. \(d_{model}\) values have to be generated so the position embedding can be the same dimension as the token embedding.</li> </ul> \[PE_{(pos,2i)} = \sin\left(pos/10000^{2i/d_{model}}\right) \\ PE_{(pos,2i+1)} = \cos\left(pos/10000^{2i/d_{model}}\right)\] <p>These embeddings are added to the input token embeddings. This assumes that the addition of the positional encoding doesn’t cause conflicts in the embedding space (which is typically in a high dimension). However, it is also possible to concatenate position embedding values.</p> <p>For language, 1D position encodings are used. These embeddings should be designed to fit the data. For example, in images, the position embedding is 2 dimensional. For videos, an additional time dimension can be added. The embedding can be designed in any way to encode the structure of the data.</p> <h1 id="transformer-blocks">Transformer Blocks</h1> <p>The transformer blocks are where the bulk of the computation takes place. We will first go through the components needed to build these blocks, and then put them together.</p> <h2 id="attention">Attention</h2> <p>The core component of the Transformer architecture, as highlighted in the title “Attention Is All You Need,” is Attention. This concept predates transformers in Natural Language Processing (NLP). The fundamental equation for attention is:</p> \[\mathrm{Attention}(Q, K, V) = \mathrm{softmax}(\frac{QK^T}{\sqrt{d_k}})V\] <p>Attention comes in two forms: self-attention and cross-attention. We’ll begin with self-attention. It can be conceptualized as a set-to-set mapping of embeddings where information is shared among all embeddings. Here’s how it works:</p> <p>\(Q\), \(K\), and \(V\) represent queries, keys, and values. These represent different linear projections of the input embeddings that are used in the attention operation. You can think of attention as tokens communicating information with each other. Each token’s query determines which other tokens it wants to read from, while its key determines which tokens will read from it. When a token’s query matches well with another token’s key, it receives more of that token’s value. The value represents the information that the token shares with others . Through these learned projections, the model determines how information flows between tokens.</p> <p>Attention is implemented by first generating these three matrices. Let’s say the input embeddings are stored in a matrix \(X\). Learned weight matrices \(W^Q\) , \(W^K\), and \(W^V\). Are used to project the input embeddings: \(Q = W^QX, K = W^KX, V = W^VX\).</p> <p>At this stage, no information has been transferred between tokens. Given the variable number of tokens, we can’t use a single large MLP layer. To mix the information, we set each embedding to be a weighted sum of all value embeddings.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/scaled_attention-480.webp 480w,/assets/img/blog/transformer_pt1/scaled_attention-800.webp 800w,/assets/img/blog/transformer_pt1/scaled_attention-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/scaled_attention.png" class="image-fluid mx-auto d-block" width="200" height="auto" alt="Scaled Dot-Product Attention" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Scaled Dot-Product Attention <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>To compute this weighted sum, we first compute the attention matrix \(QK^T\). This matrix is of shape \((N, N)\). This is the source of the \(N^2\) complexity of transformers. The attention matrix contains scores for every combination of token query and key embeddings: \(q*k\), which is scaled by a factor \(\frac{1}{\sqrt{d_k}}\). This scaling is applied to normalize the gradients, such that the magnitude of the dot product isn’t dependent on the embedding dimension. This specific attention formulation is called scaled dot-product attention.</p> <p>A softmax is applied to each row or column, creating a weight vector for each token. This is multiplied by the value matrix to generate a weighted sum for each token. Because all matrices are learned, each token can determine which tokens to attend to, which tokens should attend to it, and what information to broadcast. This function is highly flexible. A token could even learn to nullify its own information and instead read from other tokens.</p> <p>Self-attention is like a fully connected neural network layer in that information from all tokens can propagate to other tokens. However, self-attention has the benefit of supporting variable length input.</p> <h2 id="cross-attention">Cross-Attention</h2> <p>Self-attention is a mechanism where queries, keys, and values all derive from the same set of input embeddings. In contrast, cross-attention operates on two distinct sets of embeddings, which can have different lengths. The queries come from one set, while the keys and values come from another.</p> <p>In cross-attention, the attention matrix \(QK^T\) is of shape \((N_Q, N_K)\) . \(N_Q\) is the sequence length of the queries, and \(N_K\) is the sequence length of keys. The softmax is taken on the rows, so each query token has a probability distribution with respect to keys.</p> <p>Cross-attention is particularly relevant for machine translation. In this context, the keys and values come from the source language text, while the queries come from the target language. As the model generates the translation, it attends to the set of tokens from the source language, allowing it to draw information from the original text throughout the translation process.</p> <h2 id="masked-self-attention">Masked Self-Attention</h2> <p>The transformer decoder uses causal masking. The decoder is trained to predict the next token. This task becomes trivial if the next token and all future tokens are visible, as in full self-attention. Causal masking constrains the attention operation to only look at tokens to the left, making the decoder auto-regressive (meaning each output depends only on previous outputs). This one-way flow of information is essential for generating sequences one token at a time.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/masked_attention-480.webp 480w,/assets/img/blog/transformer_pt1/masked_attention-800.webp 800w,/assets/img/blog/transformer_pt1/masked_attention-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/masked_attention.png" width="100%" height="auto" alt="Example of a masked attention matrix" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Example of a masked attention matrix </figcaption> </figure> <p>Masking is applied on the \(QK^T\) matrix. Masked indices are set to \(-\infty\), this causes the softmax function to assign zero weight to these tokens. In many implementations of attention, the mask can be customized by passing in a Boolean matrix.</p> <h2 id="multi-head-attention">Multi-Head Attention</h2> <p>Multi-head attention (MHA) is a way to increase the expressivity of the attention operator. It is essentially running multiple attention operations in parallel and concatenating the output. This improves expressivity because each head is free to attend to different tokens.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/mha-480.webp 480w,/assets/img/blog/transformer_pt1/mha-800.webp 800w,/assets/img/blog/transformer_pt1/mha-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/mha.png" class="image-fluid mx-auto d-block" width="300" height="auto" alt="Multi-Head Attention" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Multi-Head Attention <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>Multi-head attention has two scaling parameters. Feature dimension for each head \(d_v\), and number of heads \(h\).</p> <p>Each head projects the input embeddings into queries, keys, and values of size \(d_v\). This means that the weight matrices \(W^Q\) , \(W^K\), and \(W^V\) are of size \((d_{model}, d_v)\). Attention is applied to the set of queries, keys, and values independently. This results in \(h\) sets of output embeddings of size \(d_v\). The output embeddings of each head are concatenated resulting in embeddings of size \(d_v*h\). The output needs to be the same dimension as the input, so there is linear projection back to size \(d_{model}\).</p> <p>Typically the embedding dimension to each head is \(d_v = d_{model}/h\). In this case, the concatenated output is the same dimension as the input token embeddings. However, it is possible to set \(d_v\) to be higher or lower.</p> <p>The output projection, which is a linear layer \(W^O\), learns to combine the outputs of the different heads. The output size of this layer is the same as the input token embedding size. This layer allows the model to give different importance to different attention heads. When \(d_v\) is set to \(d_{model}/h\), this projection is not required for dimensionality matching. However, it is beneficial in that the information from different heads can be mixed before the residual connection.</p> <p>Multi-head attention (MHA) effectively divides the softmax operation into separate parts. Each head has a fixed amount of attention weight to distribute among different value functions. This multi-headed approach allows for more complex token interactions. One of the advantages of the attention mechanism is its interpretability. For each head, it’s possible to examine which tokens are attending to which other tokens, providing insight into the model’s internal workings.</p> <h2 id="normalization">Normalization</h2> <p>In transformer architectures, layer normalization is typically used. Unlike batch normalization, the values are independent of other items in the batch. This is because batch-wide statistics aren’t used. Layer Normalization was <a href="https://arxiv.org/abs/1607.06450" rel="external nofollow noopener" target="_blank">introduced</a> just a year prior to transformers.</p> <p>For each set \(x\) in the batch, the mean \(\mu(x)\) and variance \(\sigma(x)^2\) of the embedding values (across all \(d_{model}\) values of each embedding) are calculated. LayerNorm operates on each embedding in the input completely independently. These values are used to normalize each embedding value:</p> \[\mathrm{LN}(x) = \frac{x-\mu(x)}{\sqrt{\sigma(x)^2+\epsilon}} *\gamma +\beta\] <p>\(\gamma\) and \(\beta\) are learned scalar parameters. \(\epsilon\) is a small constant used for numerical stability.</p> <p>Layer norm is effective for multiple reasons. Since batch statistics aren’t used, it makes data parallelism more efficient. This is because the batch statistics do not have to be communicated between GPUs. LayerNorm is also not affected by the size of the batch, which means different batch sizes can be used at different times.</p> <p>In <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank">Attention Is All You Need</a>, the layer normalization occurs after each attention and feed-forward layer (Post-LN architecture). However, it is now more popular to put the layer normalization before these layers (Pre-LN architecture). This <a href="https://arxiv.org/abs/2002.04745" rel="external nofollow noopener" target="_blank">paper</a> from 2020 shows that the Pre-LN architecture generally performs better. This is the only fundamental change to the original transformer architecture.</p> <h2 id="feed-forward">Feed-Forward</h2> <p>After each attention layer, a small feed forward neural network processes each token embedding. This is a position-wise operation. In the original paper, this is a two layer network with a ReLU activation after the first layer. The first layer outputs a dimension \(d_{ff}=2048\). The second layer projects these embeddings back to the original token embedding dimension \(d_{model}=512\). The first layer is set to the 4x the size of the token embedding. This multiplier is arbitrary but is considered to be an effective value given the efficiency tradeoff.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/feed_forward-480.webp 480w,/assets/img/blog/transformer_pt1/feed_forward-800.webp 800w,/assets/img/blog/transformer_pt1/feed_forward-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/feed_forward.png" class="image-fluid mx-auto d-block" width="200" height="auto" alt="Feed Forward Layer" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Feed Forward Layer </figcaption> </figure> <p>The attention layer has \(4*d_{model}*d_{model}\) parameters (accounting for query, key, value, and output projection matrices), which is \(1.0*10^6\) for the default embedding size. The feed forward layer has \(d_{model}*d_{ff} + d_{ff}*d_{model}\) which is over \(2.1*10^6\) parameters with the default configuration. When \(d_{ff} = 4*d_{model}\), this is equivalent to \(8*d_{model}*d_{model}\). The feed forward layer has roughly twice the number of parameters.</p> <p>The attention layer computation scales quadratically with input length (default value is \(n=1024\)). The computational complexity of the feed forward layers is \(n*d_{model}*d_{ff}\). For attention, it is \(n^2d_{model}+d_{model}*d_{model}\). A recent trend is increasing the sequence length \(n\), which causes the attention layer to further dominate the computational cost. Due to the complexity of the attention operation and the different ways to implement it on hardware, we will skip calculating numerical values of the computation.</p> <p>The feed forward layers contain the bulk of the transformer’s parameters, while the attention layers have the bulk of the computation. Attention is meant to learn the relationships between tokens, while the feed forward layers are meant to learn the individual token representations themselves. The attention operation is computationally intense in modeling the relationships between tokens, but it does not process individual token embeddings as much. The feed forward layers complement attention by enabling complex transformations of these embeddings.</p> <p>This <a href="https://arxiv.org/abs/2012.14913" rel="external nofollow noopener" target="_blank">paper</a> by Geva et al. argues that the feed forward layers act as key value memories. The high parameter counts of these layers enable the model to store rich information about the data they are trained on. Models like GPT-4 may not have their impressive world knowledge without the storage capacity of the feed forward layer. The transformer is a powerful architecture due to its balance of computational complexity and high parameterization.</p> <h2 id="blocks">Blocks</h2> <p>Now that we have covered each component, we can describe the transformer blocks. There are three main types of transformer blocks: encoder, decoder with cross-attention, and decoder without cross-attention. These blocks can be repeated any number of times.</p> <h3 id="encoder-block">Encoder Block</h3> <p>The encoder block maps a set of embeddings to another set of embeddings. It uses full self-attention, so each token can attend to all other tokens.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/encoder_block-480.webp 480w,/assets/img/blog/transformer_pt1/encoder_block-800.webp 800w,/assets/img/blog/transformer_pt1/encoder_block-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/encoder_block.png" class="image-fluid mx-auto d-block" width="200" height="auto" alt="Encoder Block" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Encoder Block </figcaption> </figure> <h2 id="decoder-block">Decoder Block</h2> <p>The decoder block takes in a set of input embeddings but also attends to a set of embeddings from the encoder. The first attention layer processes input embeddings with causal attention. The second attention layer is cross-attention, where the keys and values come from the encoder output. This kind of block is only used in encoder-decoder architectures since it relies on the encoder output embeddings.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/decoder_cross_attention_block-480.webp 480w,/assets/img/blog/transformer_pt1/decoder_cross_attention_block-800.webp 800w,/assets/img/blog/transformer_pt1/decoder_cross_attention_block-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/decoder_cross_attention_block.png" class="image-fluid mx-auto d-block" width="300" height="auto" alt="Decoder block with cross-attention" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Decoder block with cross-attention </figcaption> </figure> <p>The cross-attention block is omitted in decoder-only transformers. This is because there are no encoder tokens to attend to. This block is identical to the encoder block, but the attention is masked.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/decoder_block-480.webp 480w,/assets/img/blog/transformer_pt1/decoder_block-800.webp 800w,/assets/img/blog/transformer_pt1/decoder_block-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/decoder_block.png" class="image-fluid mx-auto d-block" width="200" height="auto" alt="Decoder block without cross-attention" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> Decoder block without cross-attention </figcaption> </figure> <h2 id="encoder-only-decoder-only-and-encoder-decoder-architectures">Encoder-Only, Decoder-Only, and Encoder-Decoder Architectures</h2> <p>The original transformer paper introduced an encoder-decoder architecture. Since then, encoder-only and decoder-only architectures have gained significant popularity for various use cases. You can even have “encoder-heavy” or “decoder-heavy” architectures where one part of the transformer has more layers than the other. Let’s explore the different types of transformer models and their applications.</p> <h3 id="encoder-decoder">Encoder-Decoder</h3> <p>The encoder-decoder architecture can be viewed as two interconnected transformers. An encoder, which is a stack of encoder blocks, maps a sequence of input embeddings to output embeddings. A stack of decoder blocks with cross-attention then processes these embeddings. The decoder blocks read the final output embeddings from the encoder in the cross-attention layer.</p> <p>The encoder and decoder can process different types of data. For instance, in speech recognition, the encoder might encode audio while the decoder translates it into text.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/whisper-480.webp 480w,/assets/img/blog/transformer_pt1/whisper-800.webp 800w,/assets/img/blog/transformer_pt1/whisper-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/whisper.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="OpenAI Whisper Encoder-Decoder Architecture" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> OpenAI Whisper Encoder-Decoder Architecture <a href="https://cdn.openai.com/papers/whisper.pdf" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>This architecture employs cross-attention, whereas encoder-only and decoder-only architectures rely solely on self-attention.</p> <h3 id="encoder-only">Encoder-Only</h3> <p>Encoder-only transformers, popularized by <a href="https://arxiv.org/abs/1810.04805" rel="external nofollow noopener" target="_blank">BERT</a>, perform a one-to-one mapping of input embeddings to output embeddings. They can’t perform sequence-to-sequence modeling unless the input and output sequences have identical lengths.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt1/vit-480.webp 480w,/assets/img/blog/transformer_pt1/vit-800.webp 800w,/assets/img/blog/transformer_pt1/vit-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt1/vit.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="ViT Encoder-Only Architecture " loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> ViT Encoder-Only Architecture <a href="https://arxiv.org/abs/2010.11929" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>These models excel at scalar prediction tasks, such as classification or regression, where the output is a single value rather than a set or sequence. Text sentiment analysis and ImageNet classification are prime examples of their application.</p> <p>Encoder-only models are useful in tasks reducible to token classification. For instance, <a href="https://arxiv.org/abs/1810.04805" rel="external nofollow noopener" target="_blank">BERT</a>’s evaluation on the Stanford Question Answering Dataset (SQuAD) doesn’t generate text answers but identifies the relevant span in the input text. The task becomes classifying which tokens mark the start and end of the answer span. Similarly, Vision Transformer (ViT), another encoder-only architecture, is trained for ImageNet classification.</p> <h3 id="decoder-only">Decoder-Only</h3> <p>Decoder-only transformers have become the go-to architecture for Large Language Models (LLMs), popularized by OpenAI’s <a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf" rel="external nofollow noopener" target="_blank">GPT</a> models.</p> <p>A decoder-only model can tackle any task an encoder-decoder can handle. Instead of processing source data through a separate encoder, all data flows through the decoder. The decoder omits the cross-attention layer since there’s no encoder to attend to. Its architecture mirrors that of the encoder-only transformer, with the key difference being causal attention.</p> <p>The encoder-decoder architecture can be viewed as a constrained version of the decoder-only architecture. The separate encoding of source data in encoder-decoder models represents a form of inductive bias that decoder-only architectures generalize away from.</p> <p>Encoder-decoder models require paired source and target text sequences for training, which can limit their flexibility. In contrast, decoder-only models can process a single input sequence, making them more versatile and adaptable to various tasks.</p> <p>Decoder-only architectures have surpassed encoder-decoder models in popularity due to their simplicity and versatility. However, encoder-decoder models still offer unique advantages, such as the ability to train on encoder-specific objectives or fine-tune the encoder for downstream tasks.</p> <h1 id="output-processing">Output Processing</h1> <p>The architecture of the output processing is simple. There is a final linear layer that maps embeddings of \(d_{model}\) to the size of the prediction. The output of the linear layer and how it is applied depends on the task the model is trained on.</p> <p>Transformer models can be trained with different objectives and losses based on the use case and architecture type. We will discuss different types of objectives and how they are used for training. We will also explain how inference works under these objectives.</p> <h2 id="next-token-prediction">Next Token Prediction</h2> <p>Encoder-Decoder and Decoder-only transformers are primarily trained on next token prediction. This task involves predicting the subsequent word in a sequence based on the preceding words. The output layer is applied to each embedding, with the output size matching the input vocabulary size. A softmax function then creates a probability distribution over the token vocabulary, from which the next token is sampled.</p> <p>During training, the decoder learns to predict the next word given the context. Causal masking ensures that for each token, the model can’t see the next or subsequent tokens in the sequence.</p> <p>For each token, the ground truth preceding tokens are used as context. This is known as teacher forcing, as the generated tokens aren’t used as context. However, at inference time, autoregressive decoding is used instead. We start with a context which is the set of input tokens. For chatbots, this might be the user’s input; for translation, the source text. The model predicts the next token, which is then added to the context, and another token is sampled. This process iterates until a special <end> token is produced or a predetermined limit is reached.</end></p> <p>At each step, the model outputs a probability distribution for the next token. This allows for sampling random sequences with a tunable temperature parameter, a common input for LLM APIs. Top-k sampling is another technique where you only consider the top-k tokens after the softmax. The probabilities are renormalized before sampling again. This prevents low probability tokens from ever getting predicted. Top-p or nucleus sampling is similar but possible tokens are selected so that their probabilities do not exceed p. This is more robust to changing entropies / confidence in the model’s predictions. These parameters are tuned to strike a balance between creativity and quality.</p> <p>The paper <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank">Attention Is All You Need</a> and many other NLP applications use beam search for text generation. <a href="https://en.wikipedia.org/wiki/Beam_search" rel="external nofollow noopener" target="_blank">Beam search</a> is a search algorithm widely used in text decoding. <a href="https://thinking-teams.com/wp-content/uploads/2020/11/nmt.pdf" rel="external nofollow noopener" target="_blank">Wu et al. 2016</a> provides insights into how it is used for transformer decoding. With beam search, instead of greedily selecting the most probable next token, beam search maintains the top \(k\) most likely sequences, where \(k\) is the beam width. At each step, the model expands these \(k\) sequences with their most probable next tokens. To prevent the number of sequences from growing exponentially (\(k^n\)), only the top \(k\) paths are retained after each step. The path probability is calculated as the sum of negative log likelihoods, normalized by dividing by \(length^{\alpha}\). This method allows the model to explore multiple promising paths simultaneously, avoiding local optima that might occur from selecting single tokens. To manage computational costs and control output length, beam search requires constraints. The beam size determines the number of computed paths and token selections per step, and the length penalty \(\alpha\) exponentially penalizes longer sequences. <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank">Attention Is All You Need</a> implements this with a beam size of 4 and an \(\alpha\) value of 0.6.</p> <p>Next token prediction training is highly parallelizable due to teacher forcing. A single forward pass generates predictions and losses for each token in the input. However, inference is an iterative process requiring a forward pass for each generated token.</p> <h2 id="masked-language-modeling">Masked Language Modeling</h2> <p>Masked Language Modeling (MLM) is a training objective introduced by <a href="https://arxiv.org/abs/1810.04805" rel="external nofollow noopener" target="_blank">BERT</a>. This method trains encoder-only transformers. MLM training follows these steps:</p> <ol> <li>Randomly select 15% of the input tokens for potential masking.</li> <li>Of these selected tokens: <ul> <li>• 80% are replaced with a special [MASK] token</li> <li>• 10% are replaced with a random token</li> <li>• 10% are left unchanged</li> </ul> </li> <li>Apply the linear output layer to all masked predictions. Use cross-entropy loss to predict the correct token, regardless of how it was masked.</li> </ol> <p>The intuition behind this technique differs fundamentally from next token prediction in that it’s bidirectional. As it’s an encoder-only architecture with full self-attention, tokens to the left and right are used to predict the masked tokens accurately.</p> <p>MLM is a pretraining method that doesn’t yield directly interpretable output. The model can be used for embedding representations, where the output embedding is aggregated and used in another application. The model can also be fine-tuned on a scalar prediction task.</p> <h2 id="scalar-predictions">Scalar Predictions</h2> <p>Encoder-only transformers support a wide variety of losses in addition to MLM. While MLM is a per-token objective where outputs are generated from multiple tokens, many objectives require using an output linear layer on a singular embedding to get a single output.</p> <p>There are multiple ways to achieve this:</p> <ul> <li>• Special output token <ul> <li>BERT and ViT add a <cls> token to the input. The output embedding from this input is used for predictions.</cls> </li> </ul> </li> <li>• Output pooling <ul> <li>Alternatively, you can take the average of all the embeddings and apply the output layer on this pooled embedding.</li> </ul> </li> <li>• Attentive probing <ul> <li>Attention can process the output. A learnable query vector attends to all token embeddings, producing a weighted sum that is then used for the output layer. This is essentially a cross-attention with a fixed number of query embeddings.</li> </ul> </li> </ul> <p>Once you have a singular output embedding, it can be processed by the output linear layer, and then any loss function relevant to the objective.</p> <h1 id="conclusion">Conclusion</h1> <p>This blog post covered the basic components of early transformers. In part 2, we will cover more recent innovations that further optimize these models and enable new capabilities.</p> </div> </article> <br> <hr> <br> If you found this useful, please cite this as: <blockquote> <p>Bandaru, Rohit (Nov 2024). Transformer Design Guide (Part 1: Vanilla). https://rohitbandaru.github.io.</p> </blockquote> <p>or as a BibTeX entry:</p> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@article</span><span class="p">{</span><span class="nl">bandaru2024transformer-design-guide-part-1-vanilla</span><span class="p">,</span>
  <span class="na">title</span>   <span class="p">=</span> <span class="s">{Transformer Design Guide (Part 1: Vanilla)}</span><span class="p">,</span>
  <span class="na">author</span>  <span class="p">=</span> <span class="s">{Bandaru, Rohit}</span><span class="p">,</span>
  <span class="na">year</span>    <span class="p">=</span> <span class="s">{2024}</span><span class="p">,</span>
  <span class="na">month</span>   <span class="p">=</span> <span class="s">{Nov}</span><span class="p">,</span>
  <span class="na">url</span>     <span class="p">=</span> <span class="s">{https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt1/}</span>
<span class="p">}</span>
</code></pre></div></div> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Rohit Bandaru. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?3e7054dc4d3e3dd8f0731a48453e618e"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?3577194613afa04501eb52f8f4164de9" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-X48NHDB5RV"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-X48NHDB5RV");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-notes",title:"notes",description:"",section:"Navigation",handler:()=>{window.location.href="/notes/"}},{id:"post-transformer-design-guide-part-2-modern-architecture",title:"Transformer Design Guide (Part 2: Modern Architecture)",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Transformer-Design-Guide-Pt2/"}},{id:"post-transformer-design-guide-part-1-vanilla",title:"Transformer Design Guide (Part 1: Vanilla)",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Transformer-Design-Guide-Pt1/"}},{id:"post-self-supervision-from-videos",title:"Self-Supervision from Videos",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Self-Supervision-from-Videos/"}},{id:"post-ssl-with-vision-transformers",title:"SSL with Vision Transformers",description:"",section:"Posts",handler:()=>{window.location.href="/blog/SSL-with-Vision-Transformers/"}},{id:"post-deep-dive-into-yann-lecun-s-jepa",title:"Deep Dive into Yann LeCun\u2019s JEPA",description:"",section:"Posts",handler:()=>{window.location.href="/blog/JEPA-Deep-Dive/"}},{id:"post-scaling-deep-learning",title:"Scaling Deep Learning",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Scaling-Deep-Learning/"}},{id:"post-knowledge-distillation-as-self-supervised-learning",title:"Knowledge Distillation as Self-Supervised Learning",description:"",section:"Posts",handler:()=>{window.location.href="/blog/knowledge-distillation-ssl/"}},{id:"post-self-supervised-learning-getting-more-out-of-data",title:"Self-Supervised Learning\u200a -\u200a Getting more out of\xa0data",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Self-Supervised-Learning/"}},{id:"post-domain-adaptation",title:"Domain Adaptation",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Domain-Adaptation/"}},{id:"post-pruning-neural-networks",title:"Pruning Neural Networks",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Neural-Network-Pruning/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%72%6F%68.%62%61%6E%64%61%72%75@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/rohit-bandaru","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/rohit_bandaru","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>