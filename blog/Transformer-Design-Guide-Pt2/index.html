<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="4zEwdc_gZtK7GAY69eUGNqwH6-hIgaXtASEwUuEDEho"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Transformer Design Guide (Part 2: Modern Architecture) | Rohit Bandaru </title> <meta name="author" content="Rohit Bandaru"> <meta name="description" content="ML blog."> <meta name="keywords" content="transformer, machine-learning, llm, large-language-model, rmsnorm, gelu, swiglu, geglu, position-embedding, rope, relative-position-embedding, flashattention, moe, mixtral, llama, kv-cache, mqa, gqa"> <meta property="og:site_name" content="Rohit Bandaru"> <meta property="og:type" content="article"> <meta property="og:title" content="Rohit Bandaru | Transformer Design Guide (Part 2: Modern Architecture)"> <meta property="og:url" content="https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt2/"> <meta property="og:description" content="ML blog."> <meta property="og:image" content="https://rohitbandaru.github.io/assets/img/blog/transformer_pt2/rope.png"> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Transformer Design Guide (Part 2: Modern Architecture)"> <meta name="twitter:description" content="ML blog."> <meta name="twitter:image" content="https://rohitbandaru.github.io/assets/img/blog/transformer_pt2/rope.png"> <meta name="twitter:site" content="@rohit_bandaru"> <meta name="twitter:creator" content="@rohit_bandaru"> <script type="application/ld+json">
    {
        "author":
        {
            "@type": "Person",
            "name": "Rohit Bandaru"
        },
        "url": "https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt2/",
        "@type": "BlogPosting",
        "description": "ML blog.",
        "headline": "Transformer Design Guide (Part 2: Modern Architecture)",
        
        "sameAs": ["https://www.linkedin.com/in/rohit-bandaru", "https://twitter.com/rohit_bandaru"],
        
        "name": "Rohit Bandaru",
        "@context": "https://schema.org"
    }
  </script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/blog/favicon.ico?51e8729a60eb374d0910b53e1033a010"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt2/"> <script src="/assets/js/theme.js?bd888c560287cd675855c7662a167c4a"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Rohit</span> Bandaru </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/notes/">notes </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Transformer Design Guide (Part 2: Modern Architecture)</h1> <p class="post-meta"> Created in January 11, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/transformer"> <i class="fa-solid fa-hashtag fa-sm"></i> transformer</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>While the core transformer architecture introduced in “Attention is All You Need” remains effective and widely used today, numerous architectural improvements have emerged since its inception. Unlike the dramatic evolution seen in Convolutional Neural Networks (CNNs) from AlexNet onwards, transformer modifications tend to be more incremental and optional - the original architecture still serves as a strong baseline. This speaks to the elegant design choices made by the original authors, while leaving room for ongoing optimizations in efficiency, context length, and multimodal capabilities.</p> <p>This post will focus on changes to the Transformer architecture that have been popular in the last couple of years (as of 2024). Time will tell which of these will be relevant in the future. For a deep dive on the original transformer architecture from <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank">Attention is All You Need</a> (2017), see part 1 of this blog post. ML researchers and engineers use a lot of jargon when discussing transformers. This blog post seeks to elucidate it.</p> <p>The original transformer architecture is very powerful and can handle a very wide range of applications. However, there are some limitations that more recent research has sought to address:</p> <ul> <li>Long context <ul> <li>Transformers are limited by their \(N^2\) computational complexity. This limits the sequence length a transformer can process, especially under resource and latency constraints.</li> </ul> </li> <li>Multimodality <ul> <li>While transformers were originally developed for language processing, which remains their primary application, they have since expanded to handle nearly all data modalities and power large multimodal models.</li> </ul> </li> <li>Efficiency <ul> <li>Scaling is attributed to the recent successes of LLMs. To enable this scaling, the model architecture needs to be designed efficiently.</li> <li>There have also been some research into more efficient computation. The same operations can be rewritten to run faster on hardware.</li> </ul> </li> </ul> <p>This blog post will cover the modifications to the architecture that are popular in the ML community and are applied in cutting edge industry applications such as LLMs (GPT, Claude, Gemini). This will give the prerequisite knowledge to understand these SOTA models. Many of these optimizations are only popularly used in LLMs. I find that transformers in other modalities, such as vision transformers, tend to stick to more vanilla architectures and training procedures.</p> <p>While these architectural improvements are significant, they aren’t the main driver of AI’s remarkable progress in recent years. The real paradigm shift has come from post-training techniques. Specifically, fine-tuning and instruction tuning methods have enabled us to leverage language models more effectively for a variety of use cases. I initially planned to cover these techniques here, but as this post grew longer, I realized they deserve a part 3 to do them justice. For now, we’ll focus purely on the architectural changes to the model itself.</p> <p>Many of the topics covered in this blog are large and active areas of research. These may warrant their own blog posts to give the research justice. However, in this post, we will take a myopic view and not cover this breadth of research. This will allow us to focus on more aspects of modern transformer applications and how they relate to each other.</p> <p>To understand the current state of the art, we will look at technical reports for foundational LLMs: <a href="https://arxiv.org/abs/2303.08774" rel="external nofollow noopener" target="_blank">GPT</a>, <a href="https://arxiv.org/abs/2403.05530" rel="external nofollow noopener" target="_blank">Gemini</a>, <a href="https://arxiv.org/abs/2302.13971" rel="external nofollow noopener" target="_blank">LLaMA</a>, <a href="https://www-cdn.anthropic.com/de8ba9b01c9ab7cbabf5c33b80b7bbc618857627/Model_Card_Claude_3.pdf" rel="external nofollow noopener" target="_blank">Claude</a>. We will also look at recent papers in other modalities to see how the transformer is adapted or evolved for these use cases. However, we find that there are generally fewer architectural changes in other domains.</p> <p>Unfortunately many of the most used transformer models are opaque in that the public has access to very limited details of their architecture. Even open source models usually only make the inference code open, while keeping the training code closed. However, the following models can still help us understand the current state of the art:</p> <ul> <li>Open Source LLMs <ul> <li>LLaMA (2023): <a href="https://arxiv.org/abs/2302.13971" rel="external nofollow noopener" target="_blank">LLaMA</a>, <a href="https://arxiv.org/abs/2307.09288" rel="external nofollow noopener" target="_blank">LLaMA 2</a>, <a href="https://arxiv.org/abs/2407.21783" rel="external nofollow noopener" target="_blank">LLaMA 3</a> </li> <li>Gemma (2024): <a href="https://arxiv.org/abs/2403.08295" rel="external nofollow noopener" target="_blank">Gemma</a>, <a href="https://arxiv.org/abs/2408.00118" rel="external nofollow noopener" target="_blank">Gemma 2</a> </li> <li>Mistral (2023): <a href="https://arxiv.org/abs/2310.06825" rel="external nofollow noopener" target="_blank">Mistral 7B</a>, <a href="https://arxiv.org/abs/2401.04088" rel="external nofollow noopener" target="_blank">Mixtral of Experts</a> </li> <li>Qwen (2023): <a href="https://arxiv.org/abs/2309.16609" rel="external nofollow noopener" target="_blank">Qwen</a> </li> <li>Phi (2024): <a href="https://arxiv.org/abs/2404.14219" rel="external nofollow noopener" target="_blank">Phi-3</a>, <a href="https://arxiv.org/abs/2412.08905" rel="external nofollow noopener" target="_blank">Phi-4</a> </li> <li>DeepSeek (2024): <a href="https://arxiv.org/abs/2401.02954" rel="external nofollow noopener" target="_blank">DeepSeek LLM</a> <a href="https://arxiv.org/abs/2405.04434" rel="external nofollow noopener" target="_blank">DeepSeek V2</a> <a href="https://arxiv.org/abs/2412.19437" rel="external nofollow noopener" target="_blank">DeepSeek V3</a> </li> <li>OLMo (2024): <a href="https://arxiv.org/abs/2402.00838" rel="external nofollow noopener" target="_blank">OLMo</a>, <a href="https://arxiv.org/abs/2501.00656" rel="external nofollow noopener" target="_blank">OLMo 2</a> <ul> <li>Open training code!</li> </ul> </li> </ul> </li> <li>Text encoder LLMs <ul> <li> <a href="https://arxiv.org/abs/2412.13663" rel="external nofollow noopener" target="_blank">ModernBERT</a> (2024)</li> </ul> </li> <li>Open Source Vision Language Models <ul> <li>PaliGemma (2024): <a href="https://arxiv.org/abs/2407.07726" rel="external nofollow noopener" target="_blank">PaliGemma</a>, <a href="https://arxiv.org/abs/2412.03555" rel="external nofollow noopener" target="_blank">PaliGemma 2</a> </li> <li> <a href="https://arxiv.org/abs/2412.10302" rel="external nofollow noopener" target="_blank">DeepSeek-VL2</a> (2024)</li> </ul> </li> <li>Computer Vision Models <ul> <li> <a href="https://arxiv.org/abs/2302.05442" rel="external nofollow noopener" target="_blank">ViT-22B</a> (2023)</li> </ul> </li> <li>Many more!</li> </ul> <p>Through looking at these technical reports, you find that they share many of the same architectural improvements. This blog seeks to explain these improvements. I believe it is likely that the closed source transformers (GPT 3+, Gemini, Claude) aren’t that different.</p> <h1 id="normalization">Normalization</h1> <p>In part 1, we covered <a href="https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt1/#normalization">Pre-LayerNorm</a>. We also see in architectures such as GPT that layer norm is added before and after the feed-forward and attention layers. This change was introduced in <a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf#page=4.84" rel="external nofollow noopener" target="_blank">GPT-2</a>. Generally, adding more normalization is inexpensive and has little downside, but can significantly improve and speed up training.</p> <p>There are also new types of normalization being used. <a href="https://arxiv.org/abs/1910.07467" rel="external nofollow noopener" target="_blank">RMSNorm</a> is currently a popular variant, used in <a href="https://arxiv.org/pdf/2302.13971" rel="external nofollow noopener" target="_blank">LLaMA</a>.</p> <p>To refresh, layer normalization is defined as follows:</p> \[\mathrm{LN}(x) = \frac{x-\mu(x)}{\sqrt{\sigma(x)^2+\epsilon}} *\gamma +\beta\] <p>RMSNorm is defined as:</p> \[\mathrm{RMSNorm(x)} = \frac{x}{\mathrm{RMS}(x)} \gamma, \quad \text{where} \quad \mathrm{RMS}(x) = \sqrt{\frac{1}{N} \sum_{i=1}^N x_i^2+\epsilon}\] <p>The notation we use for RMSNorm is changed to be more aligned to the LayerNorm notation. \(x\) and \(\gamma\) are both vectors, and the division by \(\mathrm{RMS}(x)\) is broadcasted to each element of \(x\). \(\gamma\) is a vector or learned scaling parameters for each value of \(x\). It is written as \(g\) in the RMSNorm paper.</p> <p>The difference is that RMSNorm rescales the features, while LayerNorm rescales and recenters the features. RMSNorm is designed to be shift invariant and not depend on the mean or recenter the values in any way. The mean subtraction is dropped from the numerator. \(\beta\) is also dropped to avoid a learned recentering. In LN, variance \(\sigma(x)^2\) depends on the mean (\(\frac{\sum_{i=1}^{N}(x_i - \mu)^2}{N}\)). RMS is used in place of variance to be completely independent of the mean. RMSNorm is completely shift invariant.</p> <p>RMSNorm is more efficient than LayerNorm. The memory usage is halved because there is only one learned parameter \(\gamma\), since \(\beta\) is dropped. There is also less computation since there is no mean subtraction. These small efficiency gains become significant when applied to transformers with hundreds of billions of parameters. Another possible advantage is that it also constrains the model less, while still keeping the advantages of normalization.</p> <h1 id="activation-functions">Activation Functions</h1> <p>The original transformer used ReLU activation functions, which appear only between the two layers of the feed-forward block. Since then, two other activation functions have gained popularity: GeLU and SwiGLU.</p> <p>Research into activation functions remains largely empirical, with limited theoretical understanding of why certain functions outperform others. The research community has spent years optimizing every component of the transformer architecture, including the ReLU activation function. These functions should be considered for any new transformer application, but one should only expect a modest improvement in performance. Nevertheless, their mathematical formulations are quite interesting and worth understanding.</p> <blockquote> <p>“We offer no explanation as to why these architectures seem to work; we attribute their success, as all else, to divine benevolence.” - Noam Shazeer in “<a href="https://arxiv.org/abs/2002.05202" rel="external nofollow noopener" target="_blank">GLU Variants Improve Transformer</a>”</p> </blockquote> <h2 id="gaussian-error-linear-units-gelus"><a href="https://arxiv.org/abs/1606.08415" rel="external nofollow noopener" target="_blank"><strong>Gaussian Error Linear Units (GELUs)</strong></a></h2> <p>GeLU is formally defined as follows:</p> \[\mathrm{GeLU}(x)=xP(X \leq x)=x\Phi(x)\] <p>\(\Phi(x)\) or \(P(X \leq x)\) is the standard Gaussian cumulative distribution function (CDF). It is the probability of values less than \(x\) occurring in a standard normal distribution: \(\Phi(x)=P(X \leq x); X\sim\mathcal{N}(0,1)\). GeLU multiples the input by this probability.</p> <p>The CDF is defined as follows:</p> \[Φ(x) = (1/2) * [1 + \mathrm{erf}(x / √2)]\] <p>The error function is defined as:</p> \[\text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt\] <p>The integral in \(\mathrm{erf}\) needs to be approximated for practical use. There are two ways to approximate GeLU:</p> \[\mathrm{GeLU}(x)\approx0.5x(1 + \tanh[\sqrt{2/π}(x + 0.044715x^3)])\] \[\mathrm{GeLU(x)} \approx x\sigma(1.702x)\] <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/gelu-480.webp 480w,/assets/img/blog/transformer_pt2/gelu-800.webp 800w,/assets/img/blog/transformer_pt2/gelu-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/gelu.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="GeLU" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/abs/1606.08415" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>GeLU can be interpreted as a smooth version of ReLU with the added property of non-zero gradients for negative inputs.</p> <p>The GPT-2 <a href="https://github.com/openai/gpt-2/blob/master/src/model.py#L26" rel="external nofollow noopener" target="_blank">code</a> uses the longer and more exact approximation. The shorter approximation is much more computationally efficient. Nowadays, this is more popular because the difference in model performance is negligible.</p> <p>GeLU is used in BERT and GPT models. It is also popular for vision transformers such as ViT-22B.</p> <h2 id="swiglu"><a href="https://arxiv.org/abs/2002.05202" rel="external nofollow noopener" target="_blank">SwiGLU</a></h2> <p>SwiGLU builds on the <a href="https://arxiv.org/abs/1710.05941v1" rel="external nofollow noopener" target="_blank">Swish</a> activation function. This is also referred to as SiLU (Sigmoid Linear Unit) in the GeLU paper.</p> \[\mathrm{Swish}(x) = x\sigma(x) = \frac{x}{1+e^{-x}}\] <p>SwiGLU is a gated linear unit (GLU) version of this. GLUs were introduced in <a href="https://arxiv.org/abs/1612.08083" rel="external nofollow noopener" target="_blank">2016</a>. GLUs modify the feed-forward network by introducing a gating mechanism that controls information flow, allowing the network to selectively emphasize or suppress different parts of the input. This works by adding another linear transformation of the input \(Vx\) that acts as the gating function. The gating function performs element-wise multiplication with the output of the first feedforward layer and activation function. SwiGLU is a GLU that uses Swish as the activation function.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/swiglu-480.webp 480w,/assets/img/blog/transformer_pt2/swiglu-800.webp 800w,/assets/img/blog/transformer_pt2/swiglu-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/swiglu.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="SwiGLU" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> </figcaption> </figure> \[\mathrm{SwiGLU}(x) = \mathrm{Swish}(xW_1+b)⊗(Vx+c)\] <p>GLUs are more expensive since \(V\) is essentially a third linear layer in the feed-forward block, the same size as \(W_1\). To ameliorate this cost, the SwiGLU paper sets \(d_{ff}\) to \(\frac{2}{3}4d_{model}\), instead of \(4d_{model}\). \(\frac{2}{3}\)is chosen to keep the total number of parameters in the feed-forward block constant, since we have three weight matrices of the same parameter count instead of one. LLaMA also uses this ratio. However, this additional matrix multiplication is in parallel to the first linear layer. Depending on the hardware, it may have negligible training speed implications. The gating mechanism improves the performance of the model enough to warrant a reduction in the width of the feed-forward block.</p> <p>GLU also increases the expressivity of the linear layer. The first linear layer is able to represent second order polynomials like \(x^2\), due to the element-wise multiplication. This may compensate for reduced width.</p> <p>SwiGLU is used by many recent LLMs such as Mixtral/Mistral, LLaMA, and Qwen. Gemma uses GeGLU, which was introduced in the same paper as SwiGLU (<a href="https://arxiv.org/abs/2002.05202" rel="external nofollow noopener" target="_blank">GLU Variants Improve Transformer)</a>. GeGLU is a gated linear unit (GLU) variant of GeLU (GELU in place of Swish).</p> <h1 id="position-embedding">Position Embedding</h1> <p>In <a href="https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt1/#position-embedding">part 1</a>, we covered two basic implementations of position embeddings tested in the “Attention Is All You Need” paper: learned position embeddings and sinusoidal position embeddings. These absolute position embeddings are functions of each token’s position in the sequence. While these methods are straightforward, they have notable limitations.</p> <p>One key challenge is generalizing position embeddings to longer context lengths than those used in training. LLMs are typically pretrained with a fixed context length (e.g., 4096), but we often want to use them with longer sequences during inference. Learned position embeddings can’t generalize beyond their training sequence lengths since they lack embeddings for later positions. This is why sinusoidal position embeddings, which can naturally extend to any length, have become more popular.</p> <p>Another limitation is that absolute position embeddings are permutation invariant, which isn’t ideal for many applications. This has led to research into relative position embeddings, which encode the positional relationship between pairs of tokens rather than their absolute positions in the sequence.</p> <h2 id="relative-position-encoding">Relative Position Encoding</h2> <p>Relative position encoding (RPE) uses the distance between tokens to define an embedding. Absolute position embeddings are simple in that they only require adding an embedding to the input token embeddings of the model. Each token maps to one embedding. With relative position embeddings, there is an embedding for different pairs of tokens. This requires computing the embeddings in the attention operation.</p> <p>For a sequence of length n, there are \(2n-1\) different pairwise distances ranging from \(-n/2\) to \(n/2\), including 0. The distance can also be clamped by a max distance to reduce the number of parameters. These distances are mapped to learned embeddings.</p> <p>RPE was introduced by <a href="https://arxiv.org/abs/1803.02155" rel="external nofollow noopener" target="_blank">Shaw et al. 2018.</a> This particular implementation can be referred to as the Shaw relative position embedding. Rather than using matrices, the paper describes how individual attention scores, for query token \(i\) and key token \(j\).</p> <p>The following equation describes how relative position is encoded into attention:</p> \[\begin{equation}e_{ij} = \frac{(x_i W^Q)(x_j W^K+a_{ij}^K)^T}{\sqrt{d_z}}\end{equation}\] \[\begin{equation}z_i = \sum_{j=1}^{n} \alpha_{ij}(x_jW^V + a_{ij}^V)\end{equation}\] <p>Equation (1) describes how the attention scores are calculated. Equation (2) shows how relative position is encoded into the values. It essentially reweighs the values based on relative positions. \(\alpha\) is just \(e\) after softmax along the key dimension. The change from standard attention is the addition of \(a_{ij}^K\) and \(a_{ij}^V\). These are learned embeddings that bias the keys and values based on the relative position between \(i\) and \(j\). The bias on the key is different based on which query it will be in a dot product with. The embedding lookup is based on the difference between \(i\) and \(j\) and a max distance parameter \(k\). There are separate embedding tables for keys and values: \(w^K\), \(w^V\).</p> \[\begin{align*} a_{ij}^K &amp;= w^K_{\text{clip}(j-i, k)} \\ a_{ij}^V &amp;= w^V_{\text{clip}(j-i, k)} \\ \text{clip}(x, k) &amp;= \max(-k, \min(k, x)) \end{align*}\] <p>Relative position is encoded in the keys so that the attention matrix can capture positional relationships between tokens. The position can also be encoded in the values, so that positional information can be encoded in the embedding themselves. This makes sense since the attention mechanism is an information bottleneck since the scores are scalars, whereas values are embeddings. However, the paper reports that they get the best results from only adding relative position the keys. Relative position on the values does not add any additional performance but comes with an efficiency cost. We see subsequent works drop this term and focus on incorporating relative position in the attention matrix.</p> <p>Now that we have defined how we can incorporate relative position within the attention operation, we must understand how to efficiently implement this. The notation above doesn’t use matrix multiplies and we cannot naively iterate over \(i\) and \(j\) with for loops. To implement the Shaw relative position embedding, \(a^K\) and \(a^V\) are computed as two matrices of size \((N, N, h, d_k)\) and \((N, N, h, d_v)\), result in \(O(N^2hd)\) memory utilization. The memory usage is reduced to \(O(N^2d)\) by sharing these embeddings between each attention head (this is also in line with absolute position embedding). The notation above disregards the attention heads dimension for simplicity. We can formulate attention with relative position as follows:</p> \[\text{RelativeAttention} = \text{Softmax}\left(\frac{QK^T + S^{rel}}{\sqrt{d_k}}\right)V\] <p>\(S^{rel}\) represents the relative attention bias which is calculated by initializing a matrix of size \([N,N,h,d_k]\). This contains embeddings of size \(d_k\) from each pair of \(N\) positions. This matrix adds significant memory complexity and contains repeated embeddings.</p> <p>Huang et al. 2018 introduce in their <a href="https://arxiv.org/abs/1809.04281" rel="external nofollow noopener" target="_blank">Music Transformer</a> paper another optimization to RPE to bring the memory complexity down to \(O(Nd)\). The key intuition is that there are only \(2n-1\) or \(O(N)\) possible relative positions possible. The Shaw RPE matrices include many duplicate embeddings because the same pairwise distances repeat many times in the model. We can restructure the computation so that these repeated embeddings aren’t stored in memory at the same time. This implementation does not include relative position in the values.</p> <p>Music Transformer optimizes this by multiplying each query directly with the relative position embedding matrix: \(QE^{r\top}\). This produces a matrix of size \([N,N]\), matching the expected size of the attention matrix bias. \(E^r\) represents the embedding table as a matrix storing representations for every relative position (pairwise position difference). The matrix is then transformed into the correct attention bias \(S^{rel}\) through a series of operations which they refer to as a skewing procedure. While these transformations are confusing, the key point is that we avoid creating any \(O(N^2d)\) matrices. Instead, \(E^r\) only requires \(O(Nd)\) additional space, with all other matrices matching the attention matrix size of \(O(N^2)\).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/musictransformer_rpe-480.webp 480w,/assets/img/blog/transformer_pt2/musictransformer_rpe-800.webp 800w,/assets/img/blog/transformer_pt2/musictransformer_rpe-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/musictransformer_rpe.png" class="image-fluid mx-auto d-block" width="600" height="auto" alt="Music Transformer RPE" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/abs/1809.04281" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <ol> <li>Mask the top left triangle, this will be shifted to result in a causal mask</li> <li>Pad an empty “dummy” column on the left side</li> <li>Reshape the matrix from \([L,L+1]\) to \([L+1,L]\) <ol> <li>Row-major ordering would cause this to result in the values to be shifted such that the relative positions are aligned to the diagonals.</li> </ol> </li> <li>Remove the empty first row through slicing</li> </ol> <p>Since relative position is encoded into the attention layers, it possible to use it alongside absolute position embeddings. Relative position embeddings are only required to be used in the first attention layer, since the information can propagate to subsequent layers. However, it is more common to use relative position attention in all of the transformer blocks. This may ensure that the position information is not disregarded by the model. It is much less common to add absolute position embeddings in every block.</p> <p>Relative position embeddings add an inductive bias of translation invariance to the models. Given the scale of the datasets modern transformers are trained on, it seems like this bias would limit the model’s ability to learn. However, as with many results in this post, relative position embedding has empirical advantages in language modeling.</p> <h2 id="attention-biasing">Attention Biasing</h2> <p>Relative position embeddings initialize embeddings for each relative position. However this can be simplified by mapping each relative distance to a scalar bias to the attention scores.</p> <h3 id="alibi">ALiBi</h3> <p>Attention with Linear Biases (ALiBi) is another method of position embedding introduced by <a href="https://arxiv.org/abs/2108.12409" rel="external nofollow noopener" target="_blank">Press et al. 2021</a>.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/alibi-480.webp 480w,/assets/img/blog/transformer_pt2/alibi-800.webp 800w,/assets/img/blog/transformer_pt2/alibi-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/alibi.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="ALiBi" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/abs/2108.12409" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>\(m\) is a hyperparameter that can be set per attention head. No absolute position embeddings are added. This method adds a strong inductive bias for locality. The attention scores decay with relative distance. Since there are no learned parameters for position this bias can generalize to longer sequence lengths during inference. The biases can be extended indefinitely.</p> <h3 id="t5">T5</h3> <p>The T5 models introduced by <a href="https://arxiv.org/abs/1910.10683" rel="external nofollow noopener" target="_blank">Raffel et al. 2019</a>, also utilize relative biases, but make these learned parameters that are shared among all the layers. Rather than setting a single hyperparameter \(m\), each relative distance maps to a learnable scalar bias value. This is more parameter efficient when compared to RoPE since the biases are shared across all layers, and they are scalars rather than embeddings.</p> <h2 id="rope"><a href="https://arxiv.org/abs/2104.09864" rel="external nofollow noopener" target="_blank">RoPE</a></h2> <p>While relative position embeddings improve model performance, they require modifying the attention operation with position bias, adding computational complexity and memory overhead. Rotary Position Embedding (RoPE), introduced in the RoFormer paper by <a href="https://arxiv.org/abs/2104.09864" rel="external nofollow noopener" target="_blank">Su et al. 2021</a>, offers an elegant solution by encoding relative position directly into the queries and keys. This approach keeps the attention operation unchanged by leveraging mathematical properties to achieve the same benefits more efficiently.</p> <p>The attention matrix contains dot products between query and key embeddings: \(\langle q_m,k_n \rangle\) . The key property of relative position embeddings is that this dot product does not depend on the absolute positions \(m\) and \(n\), but rather the relative position \(m-n\). This is translation invariant, meaning that the output is the same if you shift \(m\) and \(n\) by any constant amount. RoPE exploits the fact that we do not care what information is in the queries and keys, we only care about the dot product.</p> \[\langle f_q(x_m,m), f_k(x_n,n) \rangle = g(x_n, x_n, m-n)\] <p>RoPE groups the embedding dimensions into groups of two adjacent indices. These two values can be considered to be defining a complex number. The first number represents the real part, and the second is the imaginary dimension.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/rope-480.webp 480w,/assets/img/blog/transformer_pt2/rope-800.webp 800w,/assets/img/blog/transformer_pt2/rope-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/rope.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="RoPE" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/abs/2104.09864" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>If the embeddings are of size \(d\), \(d/2\) of these size two blocks / complex numbers are present. The absolute position of the embedding in the input sequence is denoted \(m\).</p> <p>Each of these groups representing a vector will be rotated. There is a different angle \(\theta\) of rotation for each position \(m\) from 0 to \(d/2\).</p> \[\Theta=\{\theta_i=10000^{-2(i-1)/d},i\in[1,2,...,d/2]\}\] <p>The value 10000 follows the sinusoidal position embedding in Attention Is All You Need and is equivalent to \(\theta_1\). Each group is rotated by the angle \(m\theta_i\). The rotation matrix is defined as:</p> \[\begin{bmatrix} \cos(m\theta_i) &amp; -\sin(m\theta_i) \\ \sin(m\theta_i) &amp; \cos(m\theta_i) \end{bmatrix}\] <p>Given that \(m\) is a variable index. The \(\theta\) values define frequencies. Each group’s vector is rotated at a different frequency. This helps the model learn short and long range relationships between tokens.</p> <p>We want to multiply a vector containing \(d/2\) groups by different rotation matrices. To accomplish this, the different rotation matrices are placed on a diagonal. This matrix is sparse and the rotation can be efficiently computed.</p> \[R_{\Theta,m}^d = \begin{pmatrix}\cos m \theta_1 &amp; -\sin m \theta_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\\sin m \theta_1 &amp; \cos m \theta_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \cos m \theta_2 &amp; -\sin m \theta_2 &amp; \cdots &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \sin m \theta_2 &amp; \cos m \theta_2 &amp; \cdots &amp; 0 &amp; 0 \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cos m \theta_{d/2} &amp; -\sin m \theta_{d/2} \\0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \sin m \theta_{d/2} &amp; \cos m \theta_{d/2}\end{pmatrix}\] <p>We can multiply this matrix by the query \(Q\) and key \(K\) matrices to encode the positions. The standard attention formula can be applied to these rotated queries and keys. We have defined the rotation and the implementation of RoPE but now we’ll show how this actually encodes position.</p> <p>Let’s take a arbitrary query embedding \(q_m\) and a key embedding \(k_m\). We can assume an embedding dimension of 2 so that the query and key map to only one complex number. The multiplication with the 2d rotation matrix is equivalent with multiplying with \(e^{im\theta}\) and \(e^{in\theta}\). Multiplying a complex number \(z = x + iy\) by \(e^{imθ}\) effectively rotates \(z\) counterclockwise by an angle \(m\theta\). \(x\) and \(y\) are the two components in the embedding group. Expanding the product:</p> \[\begin{aligned}e^{imθ} * z &amp;= (\cos(mθ) + i*\sin(mθ))*(x + iy)\\ &amp;=(x*\cos(mθ)-y*\sin(mθ)) + i*(x*\sin(mθ) + y*\cos(mθ))\end{aligned}\] <p>This is equivalent to multiplying with the 2d rotation matrix, assuming the first value \(x\) in the group represents the real component and \(y\) is the second and imaginary component.</p> \[\begin{aligned}R(θ) * [x, y] &amp;= \begin{bmatrix} \cos(m\theta_i) &amp; -\sin(m\theta_i) \\ \sin(m\theta_i) &amp; \cos(m\theta_i) \end{bmatrix} * [x, y] \\ &amp;= [x*cos(θ) - y*sin(θ), x*sin(θ) + y*cos(θ)]\end{aligned}\] <p>The query embedding is rotated by \(m\theta\) and the key is rotated by \(n\theta\).</p> \[q_m^r = q_m*e^{im\theta} \\ k_n^r = k_n*e^{in\theta}\] <p>In attention we are interested in the dot product of these rotated vectors. The dot product of the vectors is equivalent to the inner product of the complex numbers the 2d vector represents. The complex inner product is defined as \(Re[ab^*]\). We take the conjugate of the rotated key embedding:</p> \[k_n^{r*} = k_n^**e^{-in\theta}\] <p>We take the conjugate value of \(b\) and take the real part of the product. This can be applied to the query key product:</p> \[q_m^r*k_n^r = Re[q_m*e^{im\theta}*k_n^{r*}e^{-in\theta}] = Re[q_m^r*k_n^{r*}e^{i(m-n)\theta}]\] <p>This shows that we have reached our desired property that the dot product depends on the relative position \(m-n\), but not the absolute positions \(m\) and \(n\). This is also translation invariant in that you can shift \(m\) and \(n\) by a constant amount and not change this dot product.</p> <p>Unlike RPE, RoPE doesn’t require modifying the attention operation. It just requires transforming the input query and key matrices. This makes RoPE easier to efficiently implement. RoPE also has no learned embeddings. Attention is All You Need shows that sinusoidal position embeddings, with no learned parameters, performs just as well as learned position embeddings. RoPE can be thought of as an extension of sinusoidal embeddings that prefers relative position information.</p> <p>We’ll now revisit the \(\theta\) parameters to understand how they affect long context inference. \(10000\) can be considered the base frequency \(b\). This is an important hyperparameter that determines the lowest and highest frequency rotations. Given the embedding dimension \(d\), the lowest frequency rotation is \(\theta_{d/2} = b^{2/d-1}\). With the settings \(b=10000\) and \(d=768\), this corresponds to a wavelength of about 9763 tokens. This means for long context LLM inference (&gt;32k tokens), this rotation would become periodic. ****This directly affects the sequence lengths that RoPE can handle effectively. If \(b\) is set too low, RoPE becomes periodic during longer context inference and performance suffers.</p> <p>RoPE is still periodic like the sinusoidal absolute position embedding in the original transformer. However the difference is that it is periodic in the relative positions, not the absolute positions. The translation invariance significantly improves performance, but there is still room for improvement in the periodicity of the relative positions. Several approaches can be used to help RoPE perform better at long context inference.</p> <h3 id="positional-interpolation">Positional Interpolation</h3> <p><a href="https://arxiv.org/abs/2306.15595" rel="external nofollow noopener" target="_blank">Tian et al. 2023</a> introduces a simple method to improve RoPE’s extrapolation capabilities. For models trained with context length \(L\) that need to handle longer contexts \(L'\) during inference, RoPE can be rescaled using:</p> \[\text{f}'(x,m)=\text{f}'(x,\frac{mL}{L'})\] <p>This rescaling reduces the rotation applied to each token embedding. Though this approach requires finetuning for the new context length, the authors show that just 200 finetuning steps yield strong results.</p> <p>Another solution is to pretrain with scaled RoPE from the start. This approach was explored in <a href="https://arxiv.org/abs/2309.16039" rel="external nofollow noopener" target="_blank">Zhang et al. 2023</a> and implemented in <a href="https://arxiv.org/abs/2407.21783" rel="external nofollow noopener" target="_blank">Llama 3</a>. By setting the base frequency \(b\) to 500,000, they achieved effective inference with context lengths of 32k. While this offers a simple solution, it may limit the model’s ability to learn proper processing of higher relative positions during training.</p> <h3 id="yarn">YaRN</h3> <p><a href="https://arxiv.org/abs/2309.00071" rel="external nofollow noopener" target="_blank">Peng et al. 2023</a> improves on positional interpolation (PI) by scaling different RoPE frequencies differently. They hypothesize that PI hurts high frequency dimensions by changing the wavelengths by a significant portion. They adapt to this by scaling high frequencies less, and low frequencies more. As we previously discusses, the low frequency components are the most important to avoid periodicity.</p> <p>This method in used in <a href="https://arxiv.org/abs/2412.19437" rel="external nofollow noopener" target="_blank">DeepSeek-V3</a> and <a href="https://arxiv.org/abs/2407.10671v1" rel="external nofollow noopener" target="_blank">Qwen2</a>.</p> <p><strong>Additional Resources</strong></p> <ul> <li><a href="https://www.youtube.com/watch?v=DwaBQbqh5aE" rel="external nofollow noopener" target="_blank">Self-Attention with Relative Position Representations – Paper explained - AI Coffee Break with Letitia</a></li> <li><a href="https://jaketae.github.io/study/relative-positional-encoding/" rel="external nofollow noopener" target="_blank">Relative Positional Encoding - Jake Tae</a></li> <li><a href="https://gudgud96.github.io/2020/04/01/annotated-music-transformer/" rel="external nofollow noopener" target="_blank">Understanding Music Transformer - gudgud96</a></li> <li><a href="https://blog.eleuther.ai/rotary-embeddings/" rel="external nofollow noopener" target="_blank">Rotary Embeddings: A Relative Revolution - EleutherAI</a></li> <li><a href="https://fleetwood.dev/posts/you-could-have-designed-SOTA-positional-encoding" rel="external nofollow noopener" target="_blank">You could have designed state of the art Positional Encoding - fleetwood.dev</a></li> <li><a href="https://nn.labml.ai/transformers/rope/index.html" rel="external nofollow noopener" target="_blank">Rotary Positional Embeddings (RoPE) - labml.ai</a></li> <li><a href="https://github.com/AliHaiderAhmad001/T5-Relative-Position" rel="external nofollow noopener" target="_blank">Relative position embeddings according to T5 paper - AliHaiderAhmad001</a></li> <li><a href="https://blog.eleuther.ai/yarn/" rel="external nofollow noopener" target="_blank">Extending the RoPE - EleuterAI</a></li> <li><a href="https://www.youtube.com/watch?v=Mn_9W1nCFLo" rel="external nofollow noopener" target="_blank">LLaMA explained: KV-Cache, Rotary Positional Embedding, RMS Norm, Grouped Query Attention, SwiGLU - Umar Jamil</a></li> </ul> <h1 id="efficient-attention">Efficient Attention</h1> <p>The \(N^2\) complexity of self-attention has long been considered a major bottleneck. There has been a lot of research into sparse attention methods, such as <a href="https://arxiv.org/abs/2007.14062" rel="external nofollow noopener" target="_blank">BigBird</a> and <a href="https://arxiv.org/abs/1904.10509" rel="external nofollow noopener" target="_blank">Sparse Transformers</a>. While these methods enhance efficiency through sparse attention patterns, they come at the cost of model performance. Because of this, we don’t see these methods adopted in frontier LLMs.</p> <p>Sliding Window Attention (SWA) is another sparse attention method introduced in <a href="https://arxiv.org/abs/2004.05150" rel="external nofollow noopener" target="_blank">Longformer</a>. Instead of having a query token attend to all prior key tokens, it attends only to \(w\) (window length) prior tokens. This reduces attention complexity from \(N^2\) to \(Nw\). However, effective performance requires a substantial window length. For example, Mistral uses a window length of half the context length. This is implemented through an attention mask during training. During inference, the KV cache (explained later) size can be reduced from \(N\) to \(w\).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/swa-480.webp 480w,/assets/img/blog/transformer_pt2/swa-800.webp 800w,/assets/img/blog/transformer_pt2/swa-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/swa.png" class="image-fluid mx-auto d-block" width="600" height="auto" alt="SWA" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/abs/2310.06825" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>SWA resembles convolution in that tokens attend only to nearby tokens. Longformer employs smaller window sizes in earlier transformer blocks and larger ones in later blocks. This enables both local and global information flow, allowing learning at different scales—similar to CNN architecture.</p> <p>A key limitation is that distant tokens cannot communicate directly. Information must flow through multiple transformer layers to connect distant tokens. To address this, models like <a href="https://arxiv.org/abs/2408.00118" rel="external nofollow noopener" target="_blank">Gemma 2</a> and <a href="https://arxiv.org/abs/2412.13663" rel="external nofollow noopener" target="_blank">ModernBERT</a> alternate between SWA and global attention blocks. By maintaining global attention blocks throughout the network, distant token can still communicate quickly. We can adjust the number of SWA blocks and window size to manage this efficiency tradeoff.</p> <p>SWA has emerged as a powerful and practical method for improving transformer efficiency. It has been gaining more traction in LLMs than other sparse attention approaches. SWA typically uses a large window size - usually half the global context length. This makes it more similar to global attention than sparse/local attention. However, it still offers substantial benefits. It halves both the KV cache size during inference. Additionally, it reduces the attention computation during both training and inference. SWA also avoids the issues of position embedding extrapolation by capping the maximum relative positions in the attention operation.</p> <h2 id="flashattention">FlashAttention</h2> <p>FlashAttention (<a href="https://arxiv.org/abs/2205.14135" rel="external nofollow noopener" target="_blank">Dao et al. 2022</a>) is an optimization to the computation of the attention operation. They are designed to be completely accurate in their results, but more efficiently run on GPUs. We will focus on <a href="https://arxiv.org/abs/2307.08691" rel="external nofollow noopener" target="_blank">FlashAttention-2</a>, which has several significant improvements. <a href="https://arxiv.org/abs/2407.08608" rel="external nofollow noopener" target="_blank">FlashAttention-3</a> is another optimization, however, it is designed specifically for NVIDIA GPUs.</p> <p>When designing algorithms like attention, we often only consider the number of floating point operations (FLOPs). However, we need to more carefully consider the hardware. Specifically, GPUs are very fast in computing highly parallelized floating point operations, but have slower memory access. We can speed up attention by reducing the amount of memory reads and writes, even if it comes at the cost of additional computation.</p> <p>GPUs have two types of memory: slow but large HBM (high bandwidth memory) and small but fast SRAM (static random access memory). When working with large matrices, we load blocks (parts of the matrices) from HBM into SRAM. The computation takes place and then the output is written back to HBM.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/gpu_memory-480.webp 480w,/assets/img/blog/transformer_pt2/gpu_memory-800.webp 800w,/assets/img/blog/transformer_pt2/gpu_memory-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/gpu_memory.png" class="image-fluid mx-auto d-block" width="400" height="auto" alt="GPU Memory Hierarchy" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/abs/2205.14135" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>We will review two prerequisite topics before covering FlashAttention.</p> <h3 id="block-matrix-multiplication-bmm">Block Matrix Multiplication (BMM)</h3> <p><a href="https://mathworld.wolfram.com/BlockMatrix.html" rel="external nofollow noopener" target="_blank">Block matrix multiplication</a> enables matrix multiplications to be parallelized by splitting the inputs into blocks and concatenating output blocks. If we are trying to compute \(C=AB\), a certain output block requires a subset of rows from \(A\) and subset of columns from \(B\). We can just take the input blocks containing these rows and columns, rather than reading the entire matrix into memory.</p> \[A = \begin{bmatrix} A_{11} &amp; A_{12} \\ A_{21} &amp; A_{22} \end{bmatrix}, \quad B = \begin{bmatrix} B_{11} &amp; B_{12} \\ B_{21} &amp; B_{22} \end{bmatrix}\] <p>Each output block \(C_{ij}\) is computed using only the required blocks: \(C_{11} = A_{11}B_{11} + A_{12}B_{21}\). The shapes of these blocks need to be carefully defined to be compatible for the matrix multiplication, and be efficient on hardware. The number of rows in the blocks of \(A\) must match the columns of blocks of \(B\).</p> <p>Computing an output block doesn’t require reading all the required input blocks at once. They can be read iteratively since it is a sum. When viewing matrix multiplication as dot products between rows and columns, the summation works by splitting these vectors into blocks, then summing the dot products of these blocks.</p> <p>Parallel GPU cores can compute different output blocks while only reading the required input blocks. Attention is just two matrix multiplications \(S = QK^\top\) and \(O = P V\) and a softmax. FlashAttention takes advantage of the BMM algorithm to compute this more efficiently.</p> <h3 id="online-softmax">Online Softmax</h3> <p>With BMM, we can compute matrix multiplications block by block without needing any global information. However, there is a challenge in integrating softmax into this framework since it requires normalizations which need to be calculated globally from all blocks.</p> <p>FlashAttention uses an online softmax to minimize the memory access. Recall the softmax operation:</p> \[\text{softmax}(x_i) = \frac{e^{x_i}}{\sum_{j=1}^n e^{x_j}}\] <p>The denominator \(l\) is the normalization factor. Also, softmax function is numerically unstable because exponents can reach extremely high values when \(x_i\) is a large positive number. To achieve numerical stability, we subtract the maximum value before computing the exponentials:</p> \[\text{softmax}(x_i) = \frac{e^{x_i - \max_j x_j}}{\sum_{j=1}^n e^{x_j - \max_j x_j}}\] <p>This subtraction keeps each exponent between 0 and 1, ensuring numerical stability. The result remains unchanged since this operation is equivalent to multiplying both numerator and denominator by the same constant. However, this maximum value is another global value.</p> <p>A naive implementation would require 3 passes, one to find the max value, one to compute the numerator and accumulate the normalization factor, and one to apply the normalization factor. This requires a lot of memory access. However, we can optimize by fusing the first two steps into a single \(O(N)\) pass using this algorithm:</p> <ol> <li>Assume the first element is the max \(m_j=s_{0j}\) and initialize an accumulator for the normalization constant as \(l_j := e^{s_{0j}-m_j}\)</li> <li>Iterate through the rest of the list <ol> <li>If the value \(s_{ij}\) is less than or equal to the current max, add it to the accumulator: \(l_j := l_j+e^{s_{ij}-m_j}\).</li> <li>If the value \(s_{ij}\) is greater than the current max, adjust the normalization factor (which was computed using the wrong max) by multiplying: \(l_j := l_j * e^{(s_{ij}-m_j)}\). This correction factor ensures \(s_{ij}-m_j\) is added to each incorrect exponent in the sum. Then update the max value: \(m_j:=s_{ij}\).</li> <li>This entire update can be expressed without conditional logic: \(m_i := \max(m_{i-1}, s_{ij});\quad l_j := l_j * e^{(m_{i-1}-m_{i})} + e^{(s_{ij}-m_{i})}\)</li> </ol> </li> </ol> <p>Through this optimization, we’ve reduced the softmax computation from three linear passes to two. The correctness of this algorithm can be simply proved by induction. The method is defined as iterating over individual items in \(x\), however, it easily extends to iterating over blocks in \(x\). We compute the local softmax within the blocks and then accumulate a global normalization factor.</p> <hr> <p>There are two main changes to attention implemented in FlashAttention: tiling and recomputation.</p> <h3 id="tiling">Tiling</h3> <p>We can reduce the number of memory reads and writes by fusing operations together. With two separate operations, the data will be read twice and written twice. If the operations can be fused together, there will be only one read and write. However, we have to consider that we are working with very large matrices and using highly parallelized computation. Block matrix multiplication along with online softmax enables us to compute attention in pass without writing the full matrix to memory.</p> <p>With tiling, we restructure the attention operation to load data block by block from HBM to SRAM. The full attention matrix of size \((N,N)\) is never materialized at once or written to HBM. This is done by looping through the blocks multiple times to avoid the need to write to memory. This is increasing computation to reduce memory access.</p> <p>With fused operations you are trading accessibility of the code for efficiency. Simple matrix operations for attention (like multiplications and softmax) are easy to understand and modify. However, when running attention at scale, implementing an optimized fused version makes practical sense. Currently, billions of dollars are being spent running attention. It is important that we make this operation as efficient as possible.</p> <h3 id="recomputation">Recomputation</h3> <p>Typically, the attention matrix is stored in HBM during the forward pass for use in the backward pass. FlashAttention takes a different approach. It recomputes the attention matrix during the backward pass instead of storing it. While this requires computing the attention matrix twice, it eliminates the need to write the large matrix to memory.</p> <p>The softmax normalization parameters from the forward pass are still stored, enabling the backward pass attention computation to be completed in a single pass.</p> <p><strong>logsumexp</strong></p> <p>For each example in the batch, we can save only one value for the softmax normalization instead of two. We need to save both the max value \(m_i\) and the normalization sum \(l_i\). We can store the logsumexp \(L_i = m_i+\log(l_i)\). We’ll show how we can compute a correct softmax with this.</p> \[\begin{aligned} \text{softmax}(x^{(j)}) &amp;= \exp(x^{(j)}-L^{(j)}) \\ &amp;=\exp(x^{(j)}-m^{(j)}-\log l^{(j)}) \\ &amp;=\frac{\exp(x^{(j)}-m^{(j)})}{\exp(\log l^{(j)})} \\ &amp;=\frac{\exp(x^{(j)}-m^{(j)})}{ l^{(j)}} \end{aligned}\] <p>This small trick reduces the memory writes from the forward pass by half.</p> <h3 id="algorithm">Algorithm</h3> <p><strong>Forward Pass</strong></p> <ol> <li>Iterate through query blocks to get \(\text{Q}_i\) (this step runs in parallel)</li> <li>For each query block, iterate through key and value blocks to obtain \(\text{K}_j\) and \(\text{V}_j\) <ol> <li>Compute the attention block \(\text{S}_i^{(j)}=\text{Q}_i\text{K}_j^T\)</li> <li>Update the maximum value \(m_i^{(j)} = \max(m_i^{j-1}, \text{rowmax}(\text{S}_i^{(j)}))\), where rowmax finds the maximum in the current block</li> <li>Compute the unnormalized attention weights for the current block using the current maximum: \(\tilde{\text{P}}_i^{(j)}=\exp(\text{S}_i^{(j)}-m_i^{(j)})\)</li> <li>Update the block output: \(\text{O}_i^{(j)} = \text{diag}(e^{m_i^{(j-1)}} - m_i^{(j)})^{-1} \text{O}_i^{(j-1)} + \tilde{\text{P}}_i^{(j)} \text{V}_j\) <ol> <li>The first term adjusts the exponents from previous blocks</li> <li>This output remains unnormalized and contains only the softmax numerator</li> </ol> </li> </ol> </li> <li>Normalize the output block and write to HBM: \(\text{O}_i=\text{diag}(l_i^{(T_c)})^{-1}\text{O}_i^{T_c}\) <ol> <li>\(T_c\) represents the final block index after completing the loop</li> </ol> </li> <li>Compute logexpsum and save to HBM for the backward pass: \(L_i = m_i^{(T_c)} + \log(l_i ^{(T_c)})\)</li> </ol> <p><strong>Backward Pass</strong></p> <ol> <li>Initialize gradient buffers in HBM for \(\text{dQ}\), \(\text{dK}\), \(\text{dV}\) <ol> <li>Initialize \(D=\text{rowsum}(\text{dO}\circ O)\) in HBM</li> </ol> </li> <li>Iterate through key and value blocks to obtain \(K_j\) and \(V_j\) <ol> <li>Initialize \(\text{dK}_j\) and \(\text{dV}_j\) in SRAM</li> <li>Iterate through the output blocks and load \(\text{Q}_i\), \(\text{O}_i\), \(\text{dO}_i\), \(\text{dQ}_i\), \(L_i\), \(D_i\) to SRAM. <ol> <li>Recompute the attention block \(\text{S}_i^{(j)}=\text{Q}_i\text{K}_j^T\)</li> <li>Normalize the attention using the saved logsumexp \(\text{P}_i^{(j)}=\exp(\text{S}_i^{(j)}-L_i)\)</li> <li>Calculate the following gradients <ol> <li> \[\text{d}\text{V}_j \leftarrow \text{d}\text{V}_j + (\text{P}_i^{(j)})^\top \text{dO}_i\] </li> <li> \[\text{d}\text{P}_i^{(j)} = \text{dO}_i \text{V}_j^\top\] </li> <li> \[\text{d}\text{S}_i^{(j)} = \text{P}_i^{(j)} \circ (\text{d}\text{P}_i^{(j)} - D_i)\] <ol> <li>This is derived from the Jacobian of the softmax</li> </ol> </li> </ol> </li> <li>Update \(\text{dQ}_i \leftarrow \text{dQ}_i + \text{dS}_i^{(j)}\text{K}_j\) <ol> <li>This read from HBM and written back. This memory expensive step is necessary since we need to accumulate gradients for all query blocks before writing the final result</li> </ol> </li> <li>Update in SRAM: \(\text{dK}_j \leftarrow \text{dK}_j + \text{dS}_i^{(j)T}\text{Q}_j\)</li> </ol> </li> <li>Write \(\text{dK}_j\) and \(\text{dV}_j\) to HBM</li> </ol> </li> </ol> <hr> <p>FlashAttention is a kernel fusion that torch.compile cannot find because it is a rewrite of the computation. NxN attention matrix is not materialized. This also allows larger values of N which is important for long context. It is now implemented in most deep learning frameworks.</p> <p>FlashAttention achieves its performance improvements through careful memory management and tiling of the attention computation. Rather than computing the full attention matrix at once, it processes smaller blocks of queries and keys, reducing the peak memory usage. This optimization is particularly important for training and inference with long sequences, where the quadratic memory scaling of attention would otherwise be prohibitive.</p> <p><strong>Additional Resources</strong></p> <ul> <li><a href="https://www.youtube.com/watch?v=zy8ChVd_oTM&amp;t=7s" rel="external nofollow noopener" target="_blank">Flash Attention derived and coded from first principles with Triton (Python) - Umar Jamil</a></li> <li><a href="https://www.youtube.com/watch?v=gMOAud7hZg4" rel="external nofollow noopener" target="_blank">FlashAttention - Tri Dao - Stanford MLSys #67</a></li> <li><a href="https://web.stanford.edu/class/archive/cs/cs224n/cs224n.1244/slides/cs224n-2024-lecture18-deployment-and-efficiency.pdf#page=6.00" rel="external nofollow noopener" target="_blank">Slides</a></li> </ul> <h1 id="mixture-of-experts-moe">Mixture of Experts (MOE)</h1> <p>Mixture of Experts (MoE) is transformer architectural change applied to all of the feed-forward blocks. Rather than having one feed-forward module in each transformer block, there are multiple parallel feed-forward blocks. A gating network selects among these blocks. These blocks are considered experts that specialize in different things. Multiple blocks are selected and the output embeddings are added together, creating a mixture.</p> <p>MoEs are considered to be sparse models. MoE models can have very high numbers of trainable parameters, but have only a fraction used for a given example during training and inference.</p> <p>MoE is generally structured as follows:</p> <ol> <li>Create \(n\) experts, which are separate versions of the feed-forward MLP block</li> <li>A gating network / router processes the token embedding \(x\) and outputs a score for each embedding. This is a vector of size \(n\). <ol> <li>The gating network is typically implemented as a single learned MLP layer: \(W_gx\)</li> </ol> </li> <li>We select the top k experts and route the token embedding to these experts.</li> <li>The output is a weighted sum between the outputs of the k selected experts <ol> <li>A softmax is used on the scores of the top k experts to normalize the weights</li> </ol> </li> </ol> <p>The number of selected experts \(k\) is chosen to be small (typically 2) to achieve this sparsity. With this approach and parameter setting, we achieve the goal of a sparse transformer architecture.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/moelayer-480.webp 480w,/assets/img/blog/transformer_pt2/moelayer-800.webp 800w,/assets/img/blog/transformer_pt2/moelayer-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/moelayer.png" class="image-fluid mx-auto d-block" width="500" height="auto" alt="MoE Layer" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/abs/2401.04088" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>We want all \(n\) experts to be utilized with roughly equal frequency. In the worst case, the same \(k\) experts are selected for every input, and the remaining experts are just a waste of space. While each input should activate only a few experts, we want to ensure that all experts are activated with roughly equal frequency over the entire training set. We want to encourage diversity in expert selection. Different MoE implements achieve this differently.</p> <h2 id="sparsely-gated-moe-2017">Sparsely Gated MoE (2017)</h2> <p><a href="https://arxiv.org/abs/1701.06538" rel="external nofollow noopener" target="_blank">Shazeer et al. 2017</a> introduces mixture of experts for language modeling, however, using LSTMs instead of transformers.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/lstm_moe-480.webp 480w,/assets/img/blog/transformer_pt2/lstm_moe-800.webp 800w,/assets/img/blog/transformer_pt2/lstm_moe-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/lstm_moe.png" class="image-fluid mx-auto d-block" width="600" height="auto" alt="MoE on LSTM" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/pdf/1701.06538" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>In order to enforce diversity, they add tunable Gaussian noise to the expert score \((xW_g)_i\) of each expert in the function \(H()\).</p> \[H(x)_i = (x \cdot W_g)_i + \text{StandardNormal()}\cdot \text{Softplus}((x \cdot W_{noise})_i)\] <p>The noise for each component is learned through \(W_{noise}\). A load balancing loss is optimizes the magnitude of the loss for different experts. Without a proper loss term, the noise would collapse to 0. This noise term is important for the load balancing loss.</p> <p>Softplus is similar to ReLU but smooth and always non-negative: \(\text{Softplus}(x)=\log(1+e^x)\). This is just to make sure the noise added is non-negative.</p> <p>After adding the noise, we apply the \(\text{KeepTopK}\) function. This sets the values to \(-\infty\) for experts outside of the top \(k\) to ignore them in the softmax. After the softmax, only two experts have weights, which add up to 1. The final weights on the experts is calculate as:</p> \[G(x) = Softmax(KeepTopK(H(x), k))\] <p>The softmax normalizes the weights of the two experts, which can be used to compute a weighted sum of the outputs of the selected experts.</p> <p>For diversity, an additional importance loss term is used. Given an expert \(i\) and a training batch \(X\), we define importance as follows:</p> \[Importance(i,X)=\sum_{x\in X}G_i(x)\] <p>We then sum this across experts to define an auxiliary loss, which is minimized when all the experts are activated equally on the batch:</p> \[L_{importance,i}(X) = w_{importance} \cdot CV(Importance(i,X))^2\] <p>However, one shortcoming of the importance loss term is that it uses the weights. It is possible for an expert to have a high average weight, but never be selected in \(KeepTopK\). They define another loss \(L_{load}\) weighted by \(w_{load}\) to address this. We want a smooth estimation of the number of examples assigned to each expert. The definition of this is out of scope for this post, but it is designed to be smooth operation on a discrete operator.</p> <p>A key challenge with MoE is that each expert only sees a fraction of the training batch, limiting its learning effectiveness. To address this, one solution is to use data parallelism with very large batch sizes.</p> <p>MoE also requires careful handling in multi-device training setups. Through expert parallelism—a form of model parallelism—different devices manage different experts. After the gating function determines expert assignments, tokens are shuffled between GPUs in a ring pattern before returning to their original GPU. This allows us to use MoE to scale the number of parameters in a model, but there is an added communication cost with expert parallelism.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/expert_parallelism-480.webp 480w,/assets/img/blog/transformer_pt2/expert_parallelism-800.webp 800w,/assets/img/blog/transformer_pt2/expert_parallelism-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/expert_parallelism.png" class="image-fluid mx-auto d-block" width="500" height="auto" alt="Expert Parallelism" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://pytorch.org/blog/training-moes/" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>The auxiliary loss is calculated separately for each MoE layer in the transformer.</p> <h2 id="gshard">GShard</h2> <p><a href="https://arxiv.org/abs/2006.16668" rel="external nofollow noopener" target="_blank">GShard</a> (Lepikhin et al. 2020) applies MoE to transformer, also with k=2 experts. Each expert implements the same two-layer MLP architecture used in standard transformers. GShard uses a simpler auxiliary loss term to encourage expert diversity. It is simply \(\frac{c_e}{S}m_e\) where \(e\) is a particular expert. This loss is averaged across all experts. \(c_e/S\) is the fraction of the \(S\) tokens routed to expert \(e\). This is not differentiable because \(c_e\) is determined by the top k operator. This ratio acts as a weight on the mean weight of the expert \(m_e\) which is differentiable. The authors were able to train very large MoE transformer models while using this loss to balance tokens between experts.</p> <p>The expert with the highest score is selected first. For the second expert, rather than choosing the next highest score, the system randomly samples from the remaining experts. This random selection promotes diversity, functioning similarly to the Gaussian noise term.</p> <h2 id="switch-transformer">Switch Transformer</h2> <p><a href="https://arxiv.org/abs/2101.03961" rel="external nofollow noopener" target="_blank">Fedus et al. 2022</a> applies MoE to transformers with some simplifications compared to the 2017 paper. They only use one expert by setting \(k\) to 1. Instead of having separate loading balancing and importance losses, they use one auxiliary loss term (same loss as GShard):</p> \[\mathcal{L}_{aux} = \alpha N \sum_{i=1}^{N} f_i P_i\] <p>\(f_i\) is the fraction of tokens routed to expert \(i\) and \(P_i\) is the fraction of router probability routed to expert \(i\). These are among all tokens in a batch. \(f_i\) is analogous to the load balancing loss and \(P_i\) is analogous to the importance loss. \(P\) is differentiable, while \(f_i\) is not. The loss works because \(f_i\) is treated as a weight on a differentiable loss. The multiplication with \(N\) ensures that the optimal loss is the same with different numbers of experts.</p> <h2 id="frontier-llms">Frontier LLMs</h2> <h3 id="mixtral">Mixtral</h3> <p>MoEs gained significant popularity in LLMs with the <a href="https://arxiv.org/pdf/2401.04088.pdf" rel="external nofollow noopener" target="_blank">Mixtral</a> paper from Mistral AI. The model uses 8 experts but selects only 2 for each computation, with SwiGLU serving as the expert function. The MoE block operates as follows, where \(x\) represents input token embeddings and \(y\) represents output token embeddings:</p> \[y = \sum_{i=0}^{n-1} \text{Softmax}(\text{Top2}(x \cdot W_g))_i \cdot \text{SwiGLU}_i(x)\] <p>While the paper doesn’t detail the exact auxiliary loss, the Hugging Face <a href="https://github.com/huggingface/transformers/blob/main/src/transformers/models/mixtral/modeling_mixtral.py#L886" rel="external nofollow noopener" target="_blank">implementation</a> extends the Switch Transformer loss to work with any number of selected experts.</p> <h3 id="deepseek">DeepSeek</h3> <p>DeepSeek shares more <a href="https://arxiv.org/abs/2401.06066" rel="external nofollow noopener" target="_blank">details</a> in how they train their MoE models. They do not use an auxiliary loss. Instead, they add a bias term \(b_i\) to the scores of each expert. At the end of each training step, they update the biases by \(\gamma\), which they term as the bias update speed. If the expert is overloaded, the bias is subtracted. If it is underloaded, it is added. This is heuristic method that avoids the challenges of optimizing an auxiliary loss.</p> <p>Although they don’t use an auxiliary loss for load balancing between experts, they do use one to encourage expert diversity within sequences. Their goal is for tokens within a single example to use different experts. This contrasts with other methods and challenges the intuition that experts should specialize in specific topics. They find empirically that this reduces expert specialization. They implement this similarly to the Switch Transformer loss but average the probabilities within a sequence. However, a recent paper by <a href="https://arxiv.org/abs/2408.15664" rel="external nofollow noopener" target="_blank">Wang et al. 2024</a> suggests this loss isn’t necessary for achieving expert diversity across sequences.</p> <p>They also introduce the notion of shared experts. They have routed experts which are selected by a gating function. The shared experts are always used. These are meant to store more general knowledge, while the routed experts are more specialized. This requires having more experts activated if you want to have more than 1 routed expert. DeepSeek-V3 uses high numbers of experts (ex: 2 shared, 64 routed). To implement this efficiently, they implement each expert as a 2 layer MLP with a small hidden dimension.</p> <p>MoE represents one of the most significant improvements to the transformer architecture. However, the research community has yet to converge on a standard implementation. Different papers approach expert diversity in varying ways. Understanding these documented methods provides a foundation for designing your own MoE model. The technique’s success has led to applications beyond language models into other domains, such as the <a href="https://arxiv.org/abs/2106.05974" rel="external nofollow noopener" target="_blank">Vision MoE</a> (V-MoE) paper.</p> <p><strong>Additional Resources</strong></p> <ul> <li><a href="https://www.youtube.com/watch?v=RcJ1YXHLv5o&amp;list=PLoROMvodv4rNiJRchCzutFw5ItR_Z27CM&amp;index=29&amp;ab_channel=StanfordOnline" rel="external nofollow noopener" target="_blank">Mixtral AI Talk</a></li> <li><a href="https://huggingface.co/blog/moe" rel="external nofollow noopener" target="_blank">Mixture of Experts Explained - Hugging Face</a></li> <li><a href="https://pytorch.org/blog/training-moes/" rel="external nofollow noopener" target="_blank">Training MoEs at Scale with PyTorch</a></li> <li><a href="https://www.reddit.com/r/LocalLLaMA/comments/1c7h4wq/why_llama_3_is_not_a_moe/" rel="external nofollow noopener" target="_blank">Why Llama 3 is not a MoE? - /r/LocalLLaMA</a></li> <li> <a href="https://github.com/huggingface/transformers/issues/31464" rel="external nofollow noopener" target="_blank">Bug</a> from the Hugging Face Mixtral code explaining the auxiliary loss</li> <li>Mixtral MoE inference <a href="https://github.com/mistralai/mistral-inference/blob/main/src/mistral_inference/moe.py" rel="external nofollow noopener" target="_blank">code</a> </li> <li>DeepSeek-V3 MoE inference <a href="https://github.com/deepseek-ai/DeepSeek-V3/blob/main/inference/model.py#L331" rel="external nofollow noopener" target="_blank">code</a> </li> </ul> <h1 id="kv-cache">KV Cache</h1> <p>Modern transformer architectures have introduced several innovations to improve decoding efficiency, especially for handling long sequences and reducing memory usage during inference. These improvements are essential when deploying large language models in production environments with limited computational resources.</p> <p>Decoding with an LLM involves two main steps:</p> <ol> <li>Prefill: Processing the input prompt and prior context</li> <li>Decoding: Generating new tokens</li> </ol> <p><a href="https://arxiv.org/abs/2211.05102" rel="external nofollow noopener" target="_blank">Efficiently Scaling Transformer Inference</a> (Pope et al., 2022) explores how these decoding steps can be optimized. In language model decoding, both the context and previously generated tokens are needed to predict the next token. However, reprocessing these tokens from scratch would be inefficient. Instead, we can save the intermediate outputs of prior tokens to avoid recomputation.</p> <p>Only the keys and values from the attention layers need to be preserved. Since transformer decoders use causal attention, new tokens don’t influence the embeddings of previous tokens. We can safely discard the query and output embeddings for prior tokens as they’re no longer needed for computation. The key and value embeddings are kept in the KV cache, allowing newly decoded tokens to attend to previous ones.</p> <p>During the prefill step, a KV cache is generated, containing the attention key and value tensors from each layer. This cache grows as each new token is decoded.</p> <p>The quadratic growth of KV cache with context length presents a significant scaling constraint. When we say a model uses a KV cache, it means the keys and values from previous tokens are preserved during the decoding process. The KV cache can have significant memory utilization as the number of tokens increases. However, the KV caching mechanism means that for the same model and hardware, more tokens can be processed during inference than during training.</p> <h1 id="mqagqa">MQA/GQA</h1> <p>Multi Query Attention (MQA) and Group Query Attention (GQA) are architectural changes to the attention layers of the model. These methods slightly hurt the model’s performance, but enable more efficient decoding.</p> <h2 id="multi-query-attention-mqa">Multi Query Attention (MQA)</h2> <p>Multi-Query Attention was introduced in the paper <a href="https://arxiv.org/abs/1911.02150" rel="external nofollow noopener" target="_blank">Fast Transformer Decoding: One Write-Head is All You Need</a>.</p> <p>In standard multi-head attention, each attention head has its own set of query (Q), key (K), and value (V) projections. This means that for \(h\) heads, each token will have \(h\) query, key, and value embeddings.</p> <p>MQA modifies this by using a single shared key and value head across all query heads. There are \(h\) query embeddings but only one key and value embedding. All of these embeddings are of size \(d_{model}/h\). This significantly reduces the memory footprint of the model. This is especially impactful when decoding with a long context length.</p> <p>MQA trades a minor decrease in model performance for substantial memory efficiency. The size KV cache size by a factor equal to the number of attention heads. For example, with 32 attention heads, MQA requires only 1/32 of the KV cache memory compared to standard multi-head attention. This enables decoding with longer contexts.</p> <p>Multi query attention maybe more aptly named single key and value attention, since MHA already has multiple queries. The difference is that MQA doesn’t have multiple keys and values.</p> <h2 id="group-query-attention-gqa">Group Query Attention (GQA)</h2> <p>Group-Query Attention was introduced in the paper <a href="https://arxiv.org/abs/2305.13245" rel="external nofollow noopener" target="_blank">GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints</a></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/transformer_pt2/mqa_gqa-480.webp 480w,/assets/img/blog/transformer_pt2/mqa_gqa-800.webp 800w,/assets/img/blog/transformer_pt2/mqa_gqa-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blog/transformer_pt2/mqa_gqa.png" class="image-fluid mx-auto d-block" width="500" height="auto" alt="MHA, MQA, GQA" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"> <a href="https://arxiv.org/pdf/2305.13245" rel="external nofollow noopener" target="_blank"> Source </a> </figcaption> </figure> <p>GQA is a middle ground between standard multi-head attention and Multi-Query Attention (MQA). Instead of sharing a single key-value head across all query heads (as in MQA), GQA shares key-value heads among groups of query heads.</p> <p>For example, if we have 8 query heads (\(h=8\)) and 2 key-value heads (\(g=2\)), each key-value head would be shared by 4 query heads. This provides a better balance between computational efficiency and model quality compared to MQA.</p> <p>There is reduced computational cost in that \(g\) keys and values need to be computed instead of \(h\). However, the main motivation is memory saving. <a href="https://arxiv.org/abs/2211.05102" rel="external nofollow noopener" target="_blank">Pope et al., 2022</a> shows that the memory savings of GQA enable longer context lengths. The computation of MHA might be slower. But the memory requirements can make longer context lengths impossible, due to out of memory errors. With more heads, the resource savings are further multiplied.</p> <p>GQA is currently more popular as it offers a tunable tradeoff between efficiency and quality. MQA is a special case of GQA where the number of groups is 1. Both MQA and GQA take advantage of the fact that in attention the number of keys/values and queries are not required to be the same.</p> <h1 id="conclusion">Conclusion</h1> <p>This blog post is meant to bridge the gap between “Attention Is All You Need” and frontier LLMs. While the transformer architecture has evolved significantly over the years, the original design remains remarkably relevant and far from obsolete. Very few architectural changes have been universally adopted. Individual transformer applications make different design decisions, but the transformer itself has remained universal. There have also been challengers to the transformer architecture, such as <a href="https://arxiv.org/abs/2312.00752" rel="external nofollow noopener" target="_blank">Mamba</a> . For the time being, I expect that the transformer is here to stay.</p> </div> </article> <br> <hr> <br> If you found this useful, please cite this as: <blockquote> <p>Bandaru, Rohit (Jan 2025). Transformer Design Guide (Part 2: Modern Architecture). https://rohitbandaru.github.io.</p> </blockquote> <p>or as a BibTeX entry:</p> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@article</span><span class="p">{</span><span class="nl">bandaru2025transformer-design-guide-part-2-modern-architecture</span><span class="p">,</span>
  <span class="na">title</span>   <span class="p">=</span> <span class="s">{Transformer Design Guide (Part 2: Modern Architecture)}</span><span class="p">,</span>
  <span class="na">author</span>  <span class="p">=</span> <span class="s">{Bandaru, Rohit}</span><span class="p">,</span>
  <span class="na">year</span>    <span class="p">=</span> <span class="s">{2025}</span><span class="p">,</span>
  <span class="na">month</span>   <span class="p">=</span> <span class="s">{Jan}</span><span class="p">,</span>
  <span class="na">url</span>     <span class="p">=</span> <span class="s">{https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt2/}</span>
<span class="p">}</span>
</code></pre></div></div> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Rohit Bandaru. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?3e7054dc4d3e3dd8f0731a48453e618e"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?3577194613afa04501eb52f8f4164de9" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-X48NHDB5RV"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-X48NHDB5RV");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-notes",title:"notes",description:"",section:"Navigation",handler:()=>{window.location.href="/notes/"}},{id:"post-transformer-design-guide-part-2-modern-architecture",title:"Transformer Design Guide (Part 2: Modern Architecture)",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Transformer-Design-Guide-Pt2/"}},{id:"post-transformer-design-guide-part-1-vanilla",title:"Transformer Design Guide (Part 1: Vanilla)",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Transformer-Design-Guide-Pt1/"}},{id:"post-self-supervision-from-videos",title:"Self-Supervision from Videos",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Self-Supervision-from-Videos/"}},{id:"post-ssl-with-vision-transformers",title:"SSL with Vision Transformers",description:"",section:"Posts",handler:()=>{window.location.href="/blog/SSL-with-Vision-Transformers/"}},{id:"post-deep-dive-into-yann-lecun-s-jepa",title:"Deep Dive into Yann LeCun\u2019s JEPA",description:"",section:"Posts",handler:()=>{window.location.href="/blog/JEPA-Deep-Dive/"}},{id:"post-scaling-deep-learning",title:"Scaling Deep Learning",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Scaling-Deep-Learning/"}},{id:"post-knowledge-distillation-as-self-supervised-learning",title:"Knowledge Distillation as Self-Supervised Learning",description:"",section:"Posts",handler:()=>{window.location.href="/blog/knowledge-distillation-ssl/"}},{id:"post-self-supervised-learning-getting-more-out-of-data",title:"Self-Supervised Learning\u200a -\u200a Getting more out of\xa0data",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Self-Supervised-Learning/"}},{id:"post-domain-adaptation",title:"Domain Adaptation",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Domain-Adaptation/"}},{id:"post-pruning-neural-networks",title:"Pruning Neural Networks",description:"",section:"Posts",handler:()=>{window.location.href="/blog/Neural-Network-Pruning/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%72%6F%68.%62%61%6E%64%61%72%75@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/rohit-bandaru","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/rohit_bandaru","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>